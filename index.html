<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, minimal-ui, viewport-fit=cover">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="format-detection" content="telephone=no">
    <style>
body, html {
  background: #000;
  margin: 0;
  overflow: hidden;
  padding: 0;
}

#canvas {
  display: block;
  left: 50%;
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
}

#container {
  height: 100%;
  left: 0;
  top: 0;
  position: absolute;
  width: 100%;
}
    </style>
    <title>Back to the Island</title>
  </head>
  <body>
    <div id="container">
      <canvas id="canvas">
        <p>ENOCANVAS</p>
      </canvas>
    </div>
  <script>
if (!window.AudioContext && window.webkitAudioContext) {  window.AudioContext = window.webkitAudioContext}exports={};'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class TouchHandler$1 {
    constructor(options) {
        let defaults = {
            'element': document.body,
            'start': (ev) => {},
            'move': (ev) => {},
            'end': (ev) => {},
            'width': 100,
            'height': 100,
            'left': 0,
            'top':0,
            'sticks':[]
        };
        this.currentTouches = [];
        this.options = Object.assign({}, defaults, options);

        this.startFn = (ev) => this.start(ev);
        this.moveFn = (ev) => this.move(ev);
        this.endFn = (ev) => this.end(ev);

        this.bindEvents();
    }

    addStick(stick) {
        this.options.sticks.push(stick);
    }

    removeStick(stick) {
        let index = this.options.sticks.indexOf(stick);
        if(index >= -1) {
            this.options.sticks.splice(index, 1);
        }
    }

    bindEvents() {
        let el = this.options['element'];
        el.addEventListener('touchstart', this.startFn, {passive: false});
        el.addEventListener('touchmove', this.moveFn, {passive: false});
        el.addEventListener('touchend', this.endFn, {passive: false});
        el.addEventListener('touchcancel', this.endFn, {passive: false});
    }

    unbindEvents() {
        let el = this.options['element'];
        el.removeEventListener('touchstart', this.startFn);
        el.removeEventListener('touchmove', this.moveFn);
        el.removeEventListener('touchend', this.endFn);
        el.removeEventListener('touchcancel', this.endFn);
    }

    inRange(x, y, stick) {
        let containerBounds = this.options.element.getBoundingClientRect();
        let width = containerBounds.width * (stick.options.width / 100);
        let height = containerBounds.height * (stick.options.height / 100);
        let xMin = containerBounds.width * (stick.options.left / 100);
        let yMin = containerBounds.width * (stick.options.top / 100);
        
        if( x < xMin || x > xMin + width) return false;
        if( y < yMin || y > yMin + height) return false;
        return true;
    }

    findStick(x, y) {
        let result = false;
        this.options.sticks.forEach(stick => {
            if(this.inRange(x, y, stick)) {
                result = stick;
            }
        });

        return result;
    }

    start(event) {
        for(let index = 0; index < event.targetTouches.length; index++) {
            let touch = event.targetTouches[index];
            if(this.addTouchToStick(touch)) {
                event.preventDefault();
                return false;
            }
        }

    }

    hasCurrentTouch(stick) {
        for(let index = 0; index < this.currentTouches.length; index++) {
            let currentTouch = this.currentTouches[index];
            if(currentTouch.stick == stick) {
                return true;
            }
        }
        return false;
    }

    addTouchToStick(touch) {
        let stick = this.findStick(touch.pageX, touch.pageY);
        if(this.hasCurrentTouch(stick)) return false;
        if(stick && !this.findTouch(this.currentTouches, touch.identifier)){
            this.currentTouches.push({
                identifier: touch.identifier,
                stick: stick,
                x:touch.pageX,
                y:touch.pageY
            });
            stick.start(touch);
            return true;
        }
        return false;
    }

    findTouch(touches, touchIdentifier) {
        for(let index = 0; index < touches.length; index++) {
            if(touches[index].identifier == touchIdentifier) {
                return touches[index];
            }
        }
        return false;
    }

    endOldTouches(touches) {
        for(let i = 0; i  < this.currentTouches.length; i++) {
            if(!this.findTouch(touches, this.currentTouches[i].identifier)) {
                this.currentTouches[i].stick.end();
                this.currentTouches.splice(i,1);
            }
        }
    }

    move(event) {
        if(!this.currentTouches.length) return;
        for(let i = 0; i  < event.changedTouches.length; i++) {
            let changedTouch = event.changedTouches[i];
            let existingTouch = this.findTouch(this.currentTouches, changedTouch.identifier);
            if(existingTouch) {
                let changeX = changedTouch.pageX - existingTouch.x;
                let changeY = changedTouch.pageY - existingTouch.y;
                
                existingTouch.stick.move(changeX, changeY);
                existingTouch.x = changedTouch.pageX;
                existingTouch.y = changedTouch.pageY;

                event.preventDefault();
                return false;
            }
        }

    }

    end(event) {
        if(!this.currentTouches.length) return;
        this.endOldTouches(event.targetTouches);
        event.preventDefault();

        return false; 
    }
}

class TouchContainer {
    constructor(options) {
        let defaults = {
            'container': document.body,
            'width': 50,
            'height': 50,
            'left': 0,
            'top':50
        };
        this.options = Object.assign({}, defaults, options);
        this.createElement();
    }
    createElement() {
        this.el = document.createElement('div');
        var rect = this.options.container.getBoundingClientRect();
        this.el.style.position='absolute';
        this.el.style.width = this.options.width + 'vw';
        this.el.style.height = this.options.height + 'vh';
        this.el.style.left = this.options.left + 'vw';
        this.el.style.top = this.options.top + 'vh';
        this.el.style.background= "#999999AA";
        
    }

    show() {
        this.options.container.appendChild(this.el);
    }
    hide() {
        this.options.container.removeChild(this.el);
    }
}

class Stick {
    /**
     * Creates an instance of VirtualJoyStick.
     * @param {any} options 
     * @memberof VirtualJoyStick
     */
    constructor(options) {
        let defaults = {
            'button-color': '#FF0000',
            'track-color': '#00FF0099',
            'button-size': 12.5,
            'button-stroke-size':0,
            'track-size': 15,
            'track-stroke-size':2,
            'track-stroke-color':'#FFFFFF',
            'track-stroke-size':2,
            'tracking-element': document.body,
        };
        this.options = Object.assign({}, defaults, options);
        this._isAttached = false;
        this.x = 0;
        this.y = 0;

        this.createCanvas();
    }
    /**
     * Creates the canvas
     * 
     * @memberof VirtualJoyStick
     */
    createCanvas() {
        this.ratio = window.devicePixelRatio;
        this.canvas = document.createElement('canvas');
        const dp1 = this.options['track-size'] + (this.options['track-stroke-size'] * 2);
        this.canvas.width = dp1 * this.ratio;
        this.canvas.height = dp1 * this.ratio;
        this.canvas.style.width = dp1 + 'px';
        this.canvas.style.height = dp1 + 'px';
        this.context = this.canvas.getContext('2d');
    }

    start(event) {
        if(!this._isAttached) return;

        this.x = 0;
        this.y = 0;
        this.px = 0;
        this.py = 0;
    }

    getAngle(x, y) {
        if(x == 0) {
            return 0;
        }
        return Math.atan(y/x);
    }

    getMultiplier(x) {
        return x < 0 ? -1 : 1;
    }

    getAxisDelta(x) {
        let multiplier = this.getMultiplier(x);
        return x * multiplier > 0.5 ? 1 * multiplier : 0
    }

    getAxis() {
        return {
            x: this.x,
            y: this.y,
            dx: this.getAxisDelta(this.x),
            dy: this.getAxisDelta(this.y)
        }
    }

    move(changeX, changeY) {
        
        if(!this._isAttached) return;
        this.px = this.px + changeX;
        this.py = this.py + changeY;

        let mag = Math.sqrt((this.px * this.px) + (this.py * this.py));

        let rads = this.getAngle(this.px, this.py);
        let maxX = Math.abs(Math.cos(rads));
        let maxY = Math.abs(Math.sin(rads));

        if(maxX == 1) {
            maxY = 1;
        }
        let trackRange = (this.options['track-size'] / (2 * this.ratio));
        let fx = Math.min(maxX, this.px / trackRange);
        let fy = Math.min(maxY, this.py / trackRange);
        this.x = Math.max(-maxX, fx);
        this.y = Math.max(-maxY, fy);
    }

    end(event) {
        this.x = 0;
        this.y = 0;
    }

    /**
     * Hides the joystick
     * 
     * @memberof VirtualJoyStick
     */
    hide() {
        this._isAttached = false;
        this.canvas.parentNode.removeChild(this.canvas);
    }

    /**
     * Shows the joystick
     * 
     * @memberof VirtualJoyStick
     */
    show() {
        this._isAttached = true;
        this.options['tracking-element'].appendChild(this.canvas);
    }

    setPosition(x, y) {
        this.canvas.style.position = 'absolute';
        let trackSize = (this.options['track-size'] / (2 * this.ratio));

        this.canvas.style.left = x - trackSize + 'px';
        this.canvas.style.top = y - trackSize + 'px';
    }
    /**
     * Renders a frame
     * 
     * @returns 
     * @memberof VirtualJoyStick
     */
    draw() {
        if(!this._isAttached) return;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        const trackSize = this.options['track-size'] / 2;
        this.drawCircle(
            trackSize + this.options['track-stroke-size'],
            trackSize + this.options['track-stroke-size'],
            trackSize,
            this.options['track-color'],
            this.options['track-stroke-size'] * this.ratio,
            this.options['track-stroke-color']
        );

        let trackRange = (this.options['track-size'] - this.options['button-size']) / 2;

        this.drawCircle(
            trackSize + (this.x * trackRange) + this.options['track-stroke-size'],
            trackSize + (this.y * trackRange) + this.options['track-stroke-size'],
            (this.options['button-size'] / 2),
            this.options['button-color'],
            this.options['button-stroke-size'] * this.ratio,
            this.options['button-stroke-color']
        );
    }
    /**
     * Draws a circle
     * 
     * @param {any} x 
     * @param {any} y 
     * @param {any} radius 
     * @param {any} fillColor 
     * @memberof VirtualJoyStick
     */
    drawCircle(x, y, radius, fillColor, strokeSize,strokeColor) {
        this.context.beginPath();
        this.context.arc(x,y,radius, 0, 2 * Math.PI, false);
        this.context.fillStyle = fillColor;
        this.context.lineWidth = strokeSize;
        this.context.strokeStyle = strokeColor;
        this.context.fill();
        this.context.stroke();
    }
}

const TouchHandler = TouchHandler$1;

class VirtualStick {
    constructor(options) {
        const defaults = {
            'container': document.body,
            'left': 0,
            'top': 0,
            'width': 100,
            'height': 100,
            'track-size': 180,
            'button-size': 100,
            'button-color': '#FFFFFF99',
            'button-stroke-color': '#FFFFFF',
            'button-stroke-size': 2,
            'track-color': '#00000099',
            'track-stroke-color': '#FFFFFF',
            'track-stroke-size': 2,
            'touch-handler': null
        };

        this.options = Object.assign({}, defaults, options);

        if (!this.options['touch-handler']) {
            this.options['touch-handler'] = new TouchHandler({ 'element': this.options.container });
        }

        this.container = new TouchContainer();
        this.stick = new Stick({
            'tracking-element': this.options.container,
            'button-size': this.options['button-size'],
            'button-color': this.options['button-color'],
            'track-color': this.options['track-color'],
            'track-size': this.options['track-size'],
            'track-stroke-color': this.options['track-stroke-color'],
            'track-stroke-size': this.options['track-stroke-size']
        });

        this.options['touch-handler'].addStick(this);
    }

    start(touch) {
        this.stick.setPosition(touch.pageX, touch.pageY);
        this.stick.show();
        this.stick.start();
    }
    move(x, y) {
        this.stick.move(x, y);
    }
    end() {
        this.stick.hide();
        this.stick.end();
    }

    draw() {
        this.stick.draw();
    }

    unbind() {
        this.options['touch-handler'].removeStick(this);
    }

    getAxis() {
        return this.stick.getAxis();
    }
}

exports.TouchHandler = TouchHandler;
exports.VirtualStick = VirtualStick;
exports['default'] = VirtualStick;
;// ZzFXmicro - Zuper Zmall Zound Zynth - MIT License - Copyright 2019 Frank Force
zzfx_v=.5;zzfx_x=new AudioContext;zzfx=(e,f,a,b=1,d=.1,g=0,h=0,k=0,l=0)=>{let S=44100,P=Math.PI;a*=2*P/S;a*=1+f*(2*Math.random()-1);g*=1E3*P/(S**2);b=0<b?S*(10<b?10:b)|0:1;d*=b|0;k*=2*P/S;l*=P;f=[];for(var m=0,n=0,c=0;c<b;++c)f[c]=e*zzfx_v*Math.cos(m*a*Math.cos(n*k+l))*(c<d?c/d:1-(c-d)/(b-d)),m+=1+h*(2*Math.random()-1),n+=1+h*(2*Math.random()-1),a+=g;e=zzfx_x.createBuffer(1,b,S);a=zzfx_x.createBufferSource();e.getChannelData(0).set(f);a.buffer=e;a.connect(zzfx_x.destination);a.start();return a}
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
(function () {
  'use strict';

  /**
   * A simple event system. Allows you to hook into Kontra lifecycle events or create your own, such as for [Plugins](api/plugin).
   *
   * ```js
   * import { on, off, emit } from 'kontra';
   *
   * function callback(a, b, c) {
   *   console.log({a, b, c});
   * });
   *
   * on('myEvent', callback);
   * emit('myEvent', 1, 2, 3);  //=> {a: 1, b: 2, c: 3}
   * off('myEvent', callback);
   * ```
   * @sectionName Events
   */

  // expose for testing
  let callbacks = {};

  /**
   * Call all callback functions for the event. All arguments will be passed to the callback functions.
   * @function emit
   *
   * @param {String} event - Name of the event.
   * @param {*} [args] - Arguments passed to all callbacks.
   */
  function emit(event, ...args) {
    if (!callbacks[event]) return;
    callbacks[event].map(fn => fn(...args));
  }

  /**
   * Functions for initializing the Kontra library and getting the canvas and context
   * objects.
   *
   * ```js
   * import { getCanvas, getContext, init } from 'kontra';
   *
   * let { canvas, context } = init();
   *
   * // or can get canvas and context through functions
   * canvas = getCanvas();
   * context = getContext();
   * ```
   * @sectionName Core
   */

  let canvasEl;
  let context;

  /**
   * Return the canvas element.
   * @function getCanvas
   *
   * @returns {HTMLCanvasElement} The canvas element for the game.
   */
  function getCanvas() {
    return canvasEl;
  }

  /**
   * Return the context object.
   * @function getContext
   *
   * @returns {CanvasRenderingContext2D} The context object the game draws to.
   */
  function getContext() {
    return context;
  }

  /**
   * Initialize the library and set up the canvas. Typically you will call `init()` as the first thing and give it the canvas to use. This will allow all Kontra objects to reference the canvas when created.
   *
   * ```js
   * import { init } from 'kontra';
   *
   * let { canvas, context } = init('game');
   * ```
   * @function init
   *
   * @param {String|HTMLCanvasElement} [canvas] - The canvas for Kontra to use. Can either be the ID of the canvas element or the canvas element itself. Defaults to using the first canvas element on the page.
   *
   * @returns {Object} An object with properties `canvas` and `context`. `canvas` it the canvas element for the game and `context` is the context object the game draws to.
   */
  function init(canvas) {

    // check if canvas is a string first, an element next, or default to getting
    // first canvas on page
    canvasEl = document.getElementById(canvas) ||
               canvas ||
               document.querySelector('canvas');

    // @if DEBUG
    if (!canvasEl) {
      throw Error('You must provide a canvas element for the game');
    }
    // @endif

    context = canvasEl.getContext('2d');
    context.imageSmoothingEnabled = false;

    emit('init');

    return { canvas: canvasEl, context };
  }

  // expose for testing


  // Override the getCanPlay function to provide a specific return type for tests

  /**
   * Noop function
   */
  const noop = () => {};

  /**
   * Clear the canvas.
   */
  function clear() {
    let canvas = getCanvas();
    getContext().clearRect(0, 0, canvas.width, canvas.height);
  }

  /**
   * The game loop updates and renders the game every frame. The game loop is stopped by default and will not start until the loops `start()` function is called.
   *
   * The game loop uses a time-based animation with a fixed `dt` to [avoid frame rate issues](http://blog.sklambert.com/using-time-based-animation-implement/). Each update call is guaranteed to equal 1/60 of a second.
   *
   * This means that you can avoid having to do time based calculations in your update functions  and instead do fixed updates.
   *
   * ```js
   * import { Sprite, GameLoop } from 'kontra';
   *
   * let sprite = Sprite({
   *   x: 100,
   *   y: 200,
   *   width: 20,
   *   height: 40,
   *   color: 'red'
   * });
   *
   * let loop = GameLoop({
   *   update: function(dt) {
   *     // no need to determine how many pixels you want to
   *     // move every second and multiple by dt
   *     // sprite.x += 180 * dt;
   *
   *     // instead just update by how many pixels you want
   *     // to move every frame and the loop will ensure 60FPS
   *     sprite.x += 3;
   *   },
   *   render: function() {
   *     sprite.render();
   *   }
   * });
   *
   * loop.start();
   * ```
   * @sectionName GameLoop
   *
   * @param {Object}   properties - Properties of the game loop.
   * @param {Function} properties.update - Function called every frame to update the game. Is passed the fixed `dt` as a parameter.
   * @param {Function} properties.render - Function called every frame to render the game.
   * @param {Number}   [properties.fps=60] - Desired frame rate.
   * @param {Boolean}  [properties.clearCanvas=true] - Clear the canvas every frame before the `render()` function is called.
   */
  function GameLoop({fps = 60, clearCanvas = true, update, render} = {}) {
    // check for required functions
    // @if DEBUG
    if ( !(update && render) ) {
      throw Error('You must provide update() and render() functions');
    }
    // @endif

    // animation variables
    let accumulator = 0;
    let delta = 1E3 / fps;  // delta between performance.now timings (in ms)
    let step = 1 / fps;
    let clearFn = clearCanvas ? clear : noop;
    let last, rAF, now, dt, loop;

    /**
     * Called every frame of the game loop.
     */
    function frame() {
      rAF = requestAnimationFrame(frame);

      now = performance.now();
      dt = now - last;
      last = now;

      // prevent updating the game with a very large dt if the game were to lose focus
      // and then regain focus later
      if (dt > 1E3) {
        return;
      }

      emit('tick');
      accumulator += dt;

      while (accumulator >= delta) {
        loop.update(step);

        accumulator -= delta;
      }

      clearFn();
      loop.render();
    }

    // game loop object
    loop = {
      /**
       * Called every frame to update the game. Put all of your games update logic here.
       * @memberof GameLoop
       * @function update
       *
       * @param {Number} dt - The fixed dt time of 1/60 of a frame.
       */
      update,

      /**
       * Called every frame to render the game. Put all of your games render logic here.
       * @memberof GameLoop
       * @function render
       */
      render,

      /**
       * If the game loop is currently stopped.
       *
       * ```js
       * import { GameLoop } from 'kontra';
       *
       * let loop = GameLoop({
       *   // ...
       * });
       * console.log(loop.isStopped);  //=> true
       *
       * loop.start();
       * console.log(loop.isStopped);  //=> false
       *
       * loop.stop();
       * console.log(loop.isStopped);  //=> true
       * ```
       * @memberof GameLoop
       * @property {Boolean} isStopped
       */
      isStopped: true,

      /**
       * Start the game loop.
       * @memberof GameLoop
       * @function start
       */
      start() {
        last = performance.now();
        this.isStopped = false;
        requestAnimationFrame(frame);
      },

      /**
       * Stop the game loop.
       * @memberof GameLoop
       * @function stop
       */
      stop() {
        this.isStopped = true;
        cancelAnimationFrame(rAF);
      },

      // expose properties for testing
      // @if DEBUG
      _frame: frame,
      set _last(value) {
        last = value;
      }
      // @endif
    };

    return loop;
  }

  /**
   * A minimalistic keyboard API. You can use it move the main sprite or respond to a key press.
   *
   * ```js
   * import { initKeys, keyPressed } from 'kontra';
   *
   * // this function must be called first before keyboard
   * // functions will work
   * initKeys();
   *
   * function update() {
   *   if (keyPressed('left')) {
   *     // move left
   *   }
   * }
   * ```
   * @sectionName Keyboard
   */

  /**
   * Below is a list of keys that are provided by default. If you need to extend this list, you can use the [keyMap](api/keyboard/#keyMap) property.
   *
   * - a-z
   * - 0-9
   * - enter, esc, space, left, up, right, down
   * @sectionName Available Keys
   */

  let callbacks$1 = {};
  let pressedKeys = {};

  /**
   * A map of keycodes to key names. Add to this object to expand the list of [available keys](api/keyboard/#available-keys).
   *
   * ```js
   * import { keyMap, bindKeys } from 'kontra';
   *
   * keyMap[34] = 'pageDown';
   *
   * bindKeys('pageDown', function(e) {
   *   // handle pageDown key
   * });
   * ```
   * @property {Object} keyMap
   */
  let keyMap = {
    // named keys
    'Enter': 'enter',
    'Escape': 'esc',
    'Space': 'space',
    'ArrowLeft': 'left',
    'ArrowUp': 'up',
    'ArrowRight': 'right',
    'ArrowDown': 'down',
    // for Edge compatibility
    13: 'enter',
    27: 'esc',
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down'
  };

  /**
   * Execute a function that corresponds to a keyboard key.
   *
   * @param {KeyboardEvent} evt
   */
  function keydownEventHandler(evt) {
    let key = keyMap[evt.code || evt.which];
    pressedKeys[key] = true;

    if (callbacks$1[key]) {
      callbacks$1[key](evt);
    }
  }

  /**
   * Set the released key to not being pressed.
   *
   * @param {KeyboardEvent} evt
   */
  function keyupEventHandler(evt) {
    pressedKeys[ keyMap[evt.code || evt.which] ] = false;
  }

  /**
   * Reset pressed keys.
   */
  function blurEventHandler() {
    pressedKeys = {};
  }

  /**
   * Initialize keyboard event listeners. This function must be called before using other keyboard functions.
   * @function initKeys
   */
  function initKeys() {
    let i;

    // alpha keys
    // @see https://stackoverflow.com/a/43095772/2124254
    for (i = 0; i < 26; i++) {
      // rollupjs considers this a side-effect (for now), so we'll do it in the
      // initKeys function
      keyMap[i + 65] = keyMap['Key' + String.fromCharCode(i + 65)] = String.fromCharCode(i + 97);
    }

    // numeric keys
    for (i = 0; i < 10; i++) {
      keyMap[48+i] = keyMap['Digit'+i] = ''+i;
    }

    window.addEventListener('keydown', keydownEventHandler);
    window.addEventListener('keyup', keyupEventHandler);
    window.addEventListener('blur', blurEventHandler);
  }

  /**
   * Check if a key is currently pressed. Use during an `update()` function to perform actions each frame.
   *
   * ```js
   * import { Sprite, initKeys, keyPressed } from 'kontra';
   *
   * initKeys();
   *
   * let sprite = Sprite({
   *   update: function() {
   *     if (keyPressed('left')){
   *       // left arrow pressed
   *     }
   *     else if (keyPressed('right')) {
   *       // right arrow pressed
   *     }
   *
   *     if (keyPressed('up')) {
   *       // up arrow pressed
   *     }
   *     else if (keyPressed('down')) {
   *       // down arrow pressed
   *     }
   *   }
   * });
   * ```
   * @function keyPressed
   *
   * @param {String} key - Key to check for pressed state.
   *
   * @returns {Boolean} `true` if the key is pressed, `false` otherwise.
   */
  function keyPressed(key) {
    return !!pressedKeys[key];
  }

  /**
   * A simple 2d vector object.
   *
   * ```js
   * import { Vector } from 'kontra';
   *
   * let vector = Vector(100, 200);
   * ```
   * @class Vector
   *
   * @param {Number} [x=0] - X coordinate of the vector.
   * @param {Number} [y=0] - Y coordinate of the vector.
   */
  class Vector {
    constructor(x = 0, y = 0) {
      this._x = x;
      this._y = y;
    }

    /**
     * Return a new Vector whose value is the addition of the current Vector and the passed in Vector. If `dt` is provided, the result is multiplied by the value.
     * @memberof Vector
     * @function add
     *
     * @param {kontra.Vector} vector - Vector to add to the current Vector.
     * @param {Number} [dt=1] - Time since last update.
     *
     * @returns {kontra.Vector} A new kontra.Vector instance.
     */
    add(vec, dt = 1) {
      return vectorFactory(
        this.x + (vec.x || 0) * dt,
        this.y + (vec.y || 0) * dt,
        this
      );
    }

    /**
     * Clamp the Vector between two points, preventing `x` and `y` from going below or above the minimum and maximum values. Perfect for keeping a sprite from going outside the game boundaries.
     *
     * ```js
     * import { Vector } from 'kontra';
     *
     * let vector = Vector(100, 200);
     * vector.clamp(0, 0, 200, 300);
     *
     * vector.x += 200;
     * console.log(vector.x);  //=> 200
     *
     * vector.y -= 300;
     * console.log(vector.y);  //=> 0
     *
     * vector.add({x: -500, y: 500});
     * console.log(vector);    //=> {x: 0, y: 300}
     * ```
     * @memberof Vector
     * @function clamp
     *
     * @param {Number} xMin - Minimum x value.
     * @param {Number} yMin - Minimum y value.
     * @param {Number} xMax - Maximum x value.
     * @param {Number} yMax - Maximum y value.
     */
    clamp(xMin, yMin, xMax, yMax) {
      this._c = true;
      this._a = xMin;
      this._b = yMin;
      this._d = xMax;
      this._e = yMax;
    }

    /**
     * X coordinate of the vector.
     * @memberof Vector
     * @property {Number} x
     */
    get x() {
      return this._x;
    }

    /**
     * Y coordinate of the vector.
     * @memberof Vector
     * @property {Number} y
     */
    get y() {
      return this._y;
    }

    set x(value) {
      this._x = (this._c ? Math.min( Math.max(this._a, value), this._d ) : value);
    }

    set y(value) {
      this._y = (this._c ? Math.min( Math.max(this._b, value), this._e ) : value);
    }
  }

  function vectorFactory(x, y, vec = {}) {
    let vector = new Vector(x, y);

    // preserve vector clamping when creating new vectors
    if (vec._c) {
      vector.clamp(vec._a, vec._b, vec._d, vec._e);

      // reset x and y so clamping takes effect
      vector.x = x;
      vector.y = y;
    }

    return vector;
  }
  vectorFactory.prototype = Vector.prototype;
  vectorFactory.class = Vector;

  /**
   * A versatile way to update and draw your game objects. It can handle simple rectangles, images, and sprite sheet animations. It can be used for your main player object as well as tiny particles in a particle engine.
   * @class Sprite
   *
   * @param {Object} properties - Properties of the sprite.
   * @param {Number} properties.x - X coordinate of the position vector.
   * @param {Number} properties.y - Y coordinate of the position vector.
   * @param {Number} [properties.dx] - X coordinate of the velocity vector.
   * @param {Number} [properties.dy] - Y coordinate of the velocity vector.
   * @param {Number} [properties.ddx] - X coordinate of the acceleration vector.
   * @param {Number} [properties.ddy] - Y coordinate of the acceleration vector.
   *
   * @param {String} [properties.color] - Fill color for the sprite if no image or animation is provided.
   * @param {Number} [properties.width] - Width of the sprite.
   * @param {Number} [properties.height] - Height of the sprite.
   *
   * @param {Number} [properties.ttl=Infinity] - How many frames the sprite should be alive. Used by kontra.Pool.
   * @param {Number} [properties.rotation=0] - Sprites rotation around the origin in radians.
   * @param {Number} [properties.anchor={x:0,y:0}] - The x and y origin of the sprite. {x:0, y:0} is the top left corner of the sprite, {x:1, y:1} is the bottom right corner.
   *
   * @param {Canvas​Rendering​Context2D} [properties.context] - The context the sprite should draw to. Defaults to [core.getContext()](api/core#getContext).
   *
   * @param {Image|HTMLCanvasElement} [properties.image] - Use an image to draw the sprite.
   * @param {Object} [properties.animations] - An object of [Animations](api/animation) from a kontra.Spritesheet to animate the sprite.
   *
   * @param {Function} [properties.update] - Function called every frame to update the sprite.
   * @param {Function} [properties.render] - Function called every frame to render the sprite.
   * @param {*} [properties.*] - Any additional properties you need added to the sprite. For example, if you pass `Sprite({type: 'player'})` then the sprite will also have a property of the same name and value. You can pass as many additional properties as you want.
   */
  class Sprite {
    /**
     * @docs docs/api_docs/sprite.js
     */

    constructor(properties) {
      this.init(properties);
    }

    /**
     * Use this function to reinitialize a sprite. It takes the same properties object as the constructor. Useful it you want to repurpose a sprite.
     * @memberof Sprite
     * @function init
     *
     * @param {Object} properties - Properties of the sprite.
     */
    init(properties = {}) {
      let { x, y, dx, dy, ddx, ddy, width, height, image } = properties;

      /**
       * The sprites position vector. The sprites position is its position in the world, as opposed to the position in the [viewport](api/sprite#viewX). Typically the position in the world and the viewport are the same value. If the sprite has been [added to a tileEngine](/api/tileEngine#addObject), the position vector represents where in the tile world the sprite is while the viewport represents where to draw the sprite in relation to the top-left corner of the canvas.
       * @memberof Sprite
       * @property {kontra.Vector} position
       */
      this.position = vectorFactory(x, y);

      /**
       * The sprites velocity vector.
       * @memberof Sprite
       * @property {kontra.Vector} velocity
       */
      this.velocity = vectorFactory(dx, dy);

      /**
       * The sprites acceleration vector.
       * @memberof Sprite
       * @property {kontra.Vector} acceleration
       */
      this.acceleration = vectorFactory(ddx, ddy);

      // defaults

      // sx = flipX, sy = flipY
      this._fx = this._fy = 1;

      /**
       * The rotation of the sprite around the origin in radians.
       * @memberof Sprite
       * @property {Number} rotation
       */
      this.width = this.height = this.rotation = 0;

      /**
       * How may frames the sprite should be alive. Primarily used by kontra.Pool to know when to recycle an object.
       * @memberof Sprite
       * @property {Number} ttl
       */
      this.ttl = Infinity;

      /**
       * The x and y origin of the sprite. {x:0, y:0} is the top left corner of the sprite, {x:1, y:1} is the bottom right corner.
       * @memberof Sprite
       * @property {Object} anchor
       *
       * @example
       * // exclude-code:start
       * let { Sprite } = kontra;
       * // exclude-code:end
       * // exclude-script:start
       * import { Sprite } from 'kontra';
       * // exclude-script:end
       *
       * let sprite = Sprite({
       *   x: 150,
       *   y: 100,
       *   color: 'red',
       *   width: 50,
       *   height: 50,
       *   // exclude-code:start
       *   context: context,
       *   // exclude-code:end
       *   render: function() {
       *     this.draw();
       *
       *     // draw origin
       *     this.context.fillStyle = 'yellow';
       *     this.context.beginPath();
       *     this.context.arc(this.x, this.y, 3, 0, 2*Math.PI);
       *     this.context.fill();
       *   }
       * });
       * sprite.render();
       *
       * sprite.anchor = {x: 0.5, y: 0.5};
       * sprite.x = 300;
       * sprite.render();
       *
       * sprite.anchor = {x: 1, y: 1};
       * sprite.x = 450;
       * sprite.render();
       */
      this.anchor = {x: 0, y: 0};

      /**
       * The context the sprite will draw to.
       * @memberof Sprite
       * @property {Canvas​Rendering​Context2D} context
       */
      this.context = getContext();

      /**
       * The color of the sprite if it was passed as an argument.
       * @memberof Sprite
       * @property {String} color
       */

       /**
       * The image the sprite will use when drawn if passed as an argument.
       * @memberof Sprite
       * @property {Image|HTMLCanvasElement} image
       */

      // add all properties to the sprite, overriding any defaults
      for (let prop in properties) {
        this[prop] = properties[prop];
      }

      // image sprite
      if (image) {
        this.width = (width !== undefined) ? width : image.width;
        this.height = (height !== undefined) ? height : image.height;
      }

      /**
       * The X coordinate of the camera. Used to determine [viewX](api/sprite#viewX).
       * @memberof Sprite
       * @property {Number} sx
       */
      this.sx = 0;

      /**
       * The Y coordinate of the camera. Used to determine [viewY](api/sprite#viewY).
       * @memberof Sprite
       * @property {Number} sy
       */
      this.sy = 0;
    }

    // define getter and setter shortcut functions to make it easier to work with the
    // position, velocity, and acceleration vectors.

    /**
     * X coordinate of the position vector.
     * @memberof Sprite
     * @property {Number} x
     */
    get x() {
      return this.position.x;
    }

    /**
     * Y coordinate of the position vector.
     * @memberof Sprite
     * @property {Number} y
     */
    get y() {
      return this.position.y;
    }

    /**
     * X coordinate of the velocity vector.
     * @memberof Sprite
     * @property {Number} dx
     */
    get dx() {
      return this.velocity.x;
    }

    /**
     * Y coordinate of the velocity vector.
     * @memberof Sprite
     * @property {Number} dy
     */
    get dy() {
      return this.velocity.y;
    }

    /**
     * X coordinate of the acceleration vector.
     * @memberof Sprite
     * @property {Number} ddx
     */
    get ddx() {
      return this.acceleration.x;
    }

    /**
     * Y coordinate of the acceleration vector.
     * @memberof Sprite
     * @property {Number} ddy
     */
    get ddy() {
      return this.acceleration.y;
    }

    /**
     * An object of [Animations](api/animation) from a kontra.SpriteSheet to animate the sprite. Each animation is named so that it can can be used by name for the sprites [playAnimation()](api/sprite/#playAnimation) function.
     *
     * ```js
     * import { Sprite, SpriteSheet } from 'kontra';
     *
     * let spriteSheet = SpriteSheet({
     *   // ...
     *   animations: {
     *     idle: {
     *       frames: 1,
     *       loop: false,
     *     },
     *     walk: {
     *       frames: [1,2,3]
     *     }
     *   }
     * });
     *
     * let sprite = Sprite({
     *   x: 100,
     *   y: 200,
     *   animations: spriteSheet.animations
     * });
     *
     * sprite.playAnimation('idle');
     * ```
     * @memberof Sprite
     * @property {Object} animations
     */
    get animations() {
      return this._a;
    }

    /**
     * Readonly. X coordinate of where to draw the sprite. Typically the same value as the [position vector](api/sprite#position) unless the sprite has been [added to a tileEngine](api/tileEngine#addObject).
     * @memberof Sprite
     * @property {Number} viewX
     */
    get viewX() {
      return this.x - this.sx;
    }

    /**
     * Readonly. Y coordinate of where to draw the sprite. Typically the same value as the [position vector](api/sprite#position) unless the sprite has been [added to a tileEngine](api/tileEngine#addObject).
     * @memberof Sprite
     * @property {Number} viewY
     */
    get viewY() {
      return this.y - this.sy;
    }

    /**
     * The width of the sprite. If the sprite is a [rectangle sprite](api/sprite/#rectangle-sprite), it uses the passed in value. For an [image sprite](api/sprite/#image-sprite) it is the width of the image. And for an [animation sprite](api/sprite/#animation-sprite) it is the width of a single frame of the animation.
     *
     * Setting the value to a negative number will result in the sprite being flipped across the vertical axis while the width will remain a positive value.
     * @memberof Sprite
     * @property {Number} width
     */
    get width() {
      return this._w;
    }

    /**
     * The height of the sprite. If the sprite is a [rectangle sprite](api/sprite/#rectangle-sprite), it uses the passed in value. For an [image sprite](api/sprite/#image-sprite) it is the height of the image. And for an [animation sprite](api/sprite/#animation-sprite) it is the height of a single frame of the animation.
     *
     * Setting the value to a negative number will result in the sprite being flipped across the horizontal axis while the height will remain a positive value.
     * @memberof Sprite
     * @property {Number} height
     */
    get height() {
      return this._h;
    }

    set x(value) {
      this.position.x = value;
    }
    set y(value) {
      this.position.y = value;
    }
    set dx(value) {
      this.velocity.x = value;
    }
    set dy(value) {
      this.velocity.y = value;
    }
    set ddx(value) {
      this.acceleration.x = value;
    }
    set ddy(value) {
      this.acceleration.y = value;
    }

    set animations(value) {
      let prop, firstAnimation;
      // a = animations
      this._a = {};

      // clone each animation so no sprite shares an animation
      for (prop in value) {
        this._a[prop] = value[prop].clone();

        // default the current animation to the first one in the list
        firstAnimation = firstAnimation || this._a[prop];
      }

      /**
       * The currently playing Animation object if `animations` was passed as an argument.
       * @memberof Sprite
       * @property {kontra.Animation} currentAnimation
       */
      this.currentAnimation = firstAnimation;
      this.width = this.width || firstAnimation.width;
      this.height = this.height || firstAnimation.height;
    }

    // readonly
    set viewX(value) {
      return;
    }
    set viewY(value) {
      return;
    }

    set width(value) {
      let sign = value < 0 ? -1 : 1;

      this._fx = sign;
      this._w = value * sign;
    }
    set height(value) {
      let sign = value < 0 ? -1 : 1;

      this._fy = sign;
      this._h = value * sign;
    }

    /**
     * Check if the sprite is alive. Primarily used by kontra.Pool to know when to recycle an object.
     * @memberof Sprite
     * @function isAlive
     *
     * @returns {Boolean} `true` if the sprites [ttl](api/sprite/#ttl) property is above `0`, `false` otherwise.
     */
    isAlive() {
      return this.ttl > 0;
    }

    /**
     * Check if the sprite collide with the object. Uses a simple [Axis-Aligned Bounding Box (AABB) collision check](https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection#Axis-Aligned_Bounding_Box). Takes into account the sprites [anchor](api/sprite/#anchor).
     *
     * **NOTE:** Does not take into account sprite rotation. If you need collision detection between rotated sprites you will need to implement your own `collidesWith()` function. I suggest looking at the Separate Axis Theorem.
     *
     * ```js
     * import { Sprite } from 'kontra';
     *
     * let sprite = Sprite({
     *   x: 100,
     *   y: 200,
     *   width: 20,
     *   height: 40
     * });
     *
     * let sprite2 = Sprite({
     *   x: 150,
     *   y: 200,
     *   width: 20,
     *   height: 20
     * });
     *
     * sprite.collidesWith(sprite2);  //=> false
     *
     * sprite2.x = 115;
     *
     * sprite.collidesWith(sprite2);  //=> true
     * ```
     *
     * If you need a different type of collision check, you can override this function by passing an argument by the same name.
     *
     * ```js
     * // circle collision
     * function collidesWith(object) {
     *   let dx = this.x - object.x;
     *   let dy = this.y - object.y;
     *   let distance = Math.sqrt(dx * dx + dy * dy);
     *
     *   return distance < this.radius + object.radius;
     * }
     *
     * let sprite = Sprite({
     *   x: 100,
     *   y: 200,
     *   radius: 25,
     *   collidesWith: collidesWith
     * });
     *
     * let sprite2 = Sprite({
     *   x: 150,
     *   y: 200,
     *   radius: 30,
     *   collidesWith: collidesWith
     * });
     *
     * sprite.collidesWith(sprite2);  //=> true
     * ```
     * @memberof Sprite
     * @function collidesWith
     *
     * @param {Object} object - Object to check collision against.
     *
     * @returns {Boolean|null} `true` if the objects collide, `false` otherwise. Will return `null` if the either of the two objects are rotated.
     */
    collidesWith(object) {
      if (this.rotation || object.rotation) return null;

      // take into account sprite anchors
      let x = this.x - this.width * this.anchor.x;
      let y = this.y - this.height * this.anchor.y;

      let objX = object.x;
      let objY = object.y;
      if (object.anchor) {
        objX -= object.width * object.anchor.x;
        objY -= object.height * object.anchor.y;
      }

      return x < objX + object.width &&
             x + this.width > objX &&
             y < objY + object.height &&
             y + this.height > objY;
    }

    /**
     * Update the sprites position based on its velocity and acceleration. Calls the sprites [advance()](api/sprite/#advance) function.
     * @memberof Sprite
     * @function update
     *
     * @param {Number} [dt] - Time since last update.
     */
    update(dt) {
      this.advance(dt);
    }

    /**
     * Render the sprite. Calls the sprites [draw()](api/sprite/#draw) function.
     * @memberof Sprite
     * @function render
     */
    render() {
      this.draw();
    }

    /**
     * Set the currently playing animation of an animation sprite.
     *
     * ```js
     * import { Sprite, SpriteSheet } from 'kontra';
     *
     * let spriteSheet = SpriteSheet({
     *   // ...
     *   animations: {
     *     idle: {
     *       frames: 1
     *     },
     *     walk: {
     *       frames: [1,2,3]
     *     }
     *   }
     * });
     *
     * let sprite = Sprite({
     *   x: 100,
     *   y: 200,
     *   animations: spriteSheet.animations
     * });
     *
     * sprite.playAnimation('idle');
     * ```
     * @memberof Sprite
     * @function playAnimation
     *
     * @param {String} name - Name of the animation to play.
     */
    playAnimation(name) {
      this.currentAnimation = this.animations[name];

      if (!this.currentAnimation.loop) {
        this.currentAnimation.reset();
      }
    }

    /**
     * Move the sprite by its acceleration and velocity. If the sprite is an [animation sprite](api/sprite/#animation-sprite), it also advances the animation every frame.
     *
     * If you override the sprites [update()](api/sprite/#update) function with your own update function, you can call this function to move the sprite normally.
     *
     * ```js
     * import { Sprite } from 'kontra';
     *
     * let sprite = Sprite({
     *   x: 100,
     *   y: 200,
     *   width: 20,
     *   height: 40,
     *   dx: 5,
     *   dy: 2,
     *   update: function() {
     *     // move the sprite normally
     *     sprite.advance();
     *
     *     // change the velocity at the edges of the canvas
     *     if (this.x < 0 ||
     *         this.x + this.width > this.context.canvas.width) {
     *       this.dx = -this.dx;
     *     }
     *     if (this.y < 0 ||
     *         this.y + this.height > this.context.canvas.height) {
     *       this.dy = -this.dy;
     *     }
     *   }
     * });
     * ```
     * @memberof Sprite
     * @function advance
     *
     * @param {Number} [dt] - Time since last update.
     *
     */
    advance(dt) {
      this.velocity = this.velocity.add(this.acceleration, dt);
      this.position = this.position.add(this.velocity, dt);

      this.ttl--;

      if (this.currentAnimation) {
        this.currentAnimation.update(dt);
      }
    }

    /**
     * Draw the sprite at its X and Y position. This function changes based on the type of the sprite. For a [rectangle sprite](api/sprite/#rectangle-sprite), it uses `context.fillRect()`, for an [image sprite](api/sprite/#image-sprite) it uses `context.drawImage()`, and for an [animation sprite](api/sprite/#animation-sprite) it uses the [currentAnimation](api/sprite/#currentAnimation) `render()` function.
     *
     * If you override the sprites `render()` function with your own render function, you can call this function to draw the sprite normally.
     *
     * ```js
     * import { Sprite } from 'kontra';
     *
     * let sprite = Sprite({
     *  x: 290,
     *  y: 80,
     *  color: 'red',
     *  width: 20,
     *  height: 40,
     *
     *  render: function() {
     *    // draw the rectangle sprite normally
     *    this.draw();
     *
     *    // outline the sprite
     *    this.context.strokeStyle = 'yellow';
     *    this.context.lineWidth = 2;
     *    this.context.strokeRect(this.x, this.y, this.width, this.height);
     *  }
     * });
     *
     * sprite.render();
     * ```
     * @memberof Sprite
     * @function draw
     */
    draw() {
      let anchorWidth = -this.width * this.anchor.x;
      let anchorHeight = -this.height * this.anchor.y;

      this.context.save();
      this.context.translate(this.viewX, this.viewY);

      // rotate around the anchor
      if (this.rotation) {
        this.context.rotate(this.rotation);
      }

      // flip sprite around the center so the x/y position does not change
      if (this._fx == -1 || this._fy == -1) {
        let x = this.width / 2 + anchorWidth;
        let y = this.height / 2 + anchorHeight;

        this.context.translate(x, y);
        this.context.scale(this._fx, this._fy);
        this.context.translate(-x, -y);
      }

      if (this.image) {
        this.context.drawImage(
          this.image,
          0, 0, this.image.width, this.image.height,
          anchorWidth, anchorHeight, this.width, this.height
        );
      }
      else if (this.currentAnimation) {
        this.currentAnimation.render({
          x: anchorWidth,
          y: anchorHeight,
          width: this.width,
          height: this.height,
          context: this.context
        });
      }
      else {
        this.context.fillStyle = this.color;
        this.context.fillRect(anchorWidth, anchorHeight, this.width, this.height);
      }

      this.context.restore();
    }
  }

  function spriteFactory(properties) {
    return new Sprite(properties);
  }
  spriteFactory.prototype = Sprite.prototype;
  spriteFactory.class = Sprite;

  /**
   * A tile engine for managing and drawing tilesets.
   *
   * <figure>
   *   <a href="assets/imgs/mapPack_tilesheet.png">
   *     <img src="assets/imgs/mapPack_tilesheet.png" alt="Tileset to create an overworld map in various seasons.">
   *   </a>
   *   <figcaption>Tileset image courtesy of <a href="https://kenney.nl/assets">Kenney</a>.</figcaption>
   * </figure>
   * @sectionName TileEngine
   *
   * @param {Object} properties - Properties of the tile engine.
   * @param {Number} properties.width - Width of the tile map (in number of tiles).
   * @param {Number} properties.height - Height of the tile map (in number of tiles).
   * @param {Number} properties.tilewidth - Width of a single tile (in pixels).
   * @param {Number} properties.tileheight - Height of a single tile (in pixels).
   * @param {Canvas​Rendering​Context2D} [properties.context] - The context the tile engine should draw to. Defaults to [core.getContext()](api/core#getContext)
   *
   * @param {Object[]} properties.tilesets - Array of tileset objects.
   * @param {Number} properties.tilesetN.firstgid - First tile index of the tileset. The first tileset will have a firstgid of 1 as 0 represents an empty tile.
   * @param {String|HTMLImageElement} properties.tilesetN.image - Relative path to the HTMLImageElement or an HTMLImageElement. If passing a relative path, the image file must have been [loaded](api/assets/#load) first.
   * @param {Number} [properties.tilesetN.margin=0] - The amount of whitespace between each tile (in pixels).
   * @param {Number} [properties.tilesetN.tilewidth] - Width of the tileset (in pixels). Defaults to properties.tilewidth.
   * @param {Number} [properties.tilesetN.tileheight] - Height of the tileset (in pixels). Defaults to properties.tileheight.
   * @param {String} [properties.tilesetN.source] - Relative path to the source JSON file. The source JSON file must have been [loaded](api/assets/#load) first.
   * @param {Number} [properties.tilesetN.columns] - Number of columns in the tileset image.
   *
   * @param {Object[]} properties.layers - Array of layer objects.
   * @param {String} properties.layerN.name - Unique name of the layer.
   * @param {Number[]} properties.layerN.data - 1D array of tile indices.
   * @param {Boolean} [properties.layerN.visible=true] - If the layer should be drawn or not.
   * @param {Number} [properties.layerN.opacity=1] - Percent opacity of the layer.
   */

  /**
   * @docs docs/api_docs/tileEngine.js
   */

  function TileEngine(properties = {}) {
    let {
      width,
      height,
      tilewidth,
      tileheight,
      context = getContext(),
      tilesets,
      layers
    } = properties;

    let mapwidth = width * tilewidth;
    let mapheight = height * tileheight;

    // create an off-screen canvas for pre-rendering the map
    // @see http://jsperf.com/render-vs-prerender
    let offscreenCanvas = document.createElement('canvas');
    let offscreenContext = offscreenCanvas.getContext('2d');
    offscreenCanvas.width = mapwidth;
    offscreenCanvas.height = mapheight;

    // map layer names to data
    let layerMap = {};
    let layerCanvases = {};

    // objects added to tile engine to sync with the camera
    let objects = [];

    /**
     * The width of tile map (in tiles).
     * @memberof TileEngine
     * @property {Number} width
     */

    /**
     * The height of tile map (in tiles).
     * @memberof TileEngine
     * @property {Number} height
     */

    /**
     * The width a tile (in pixels).
     * @memberof TileEngine
     * @property {Number} tilewidth
     */

    /**
     * The height of a tile (in pixels).
     * @memberof TileEngine
     * @property {Number} tileheight
     */

    /**
     * Array of all layers of the tile engine.
     * @memberof TileEngine
     * @property {Object[]} layers
     */

    /**
     * Array of all tilesets of the tile engine.
     * @memberof TileEngine
     * @property {Object[]} tilesets
     */

    let tileEngine = Object.assign({

      /**
       * The context the tile engine will draw to.
       * @memberof TileEngine
       * @property {CanvasRenderingContext2D} context
       */
      context: context,

      /**
       * The width of the tile map (in pixels).
       * @memberof TileEngine
       * @property {Number} mapwidth
       */
      mapwidth: mapwidth,

      /**
       * The height of the tile map (in pixels).
       * @memberof TileEngine
       * @property {Number} mapheight
       */
      mapheight: mapheight,
      _sx: 0,
      _sy: 0,


      // d = dirty
      _d: false,

      /**
       * X coordinate of the tile map camera.
       * @memberof TileEngine
       * @property {Number} sx
       */
      get sx() {
        return this._sx;
      },

      /**
       * Y coordinate of the tile map camera.
       * @memberof TileEngine
       * @property {Number} sy
       */
      get sy() {
        return this._sy;
      },

      // when clipping an image, sx and sy must within the image region, otherwise
      // Firefox and Safari won't draw it.
      // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a
      set sx(value) {
        this._sx = Math.min( Math.max(0, value), mapwidth - getCanvas().width );
        objects.forEach(obj => obj.sx = this._sx);
      },

      set sy(value) {
        this._sy = Math.min( Math.max(0, value), mapheight - getCanvas().height );
        objects.forEach(obj => obj.sy = this._sy);
      },

      /**
       * Render all visible layers.
       * @memberof TileEngine
       * @function render
       */
      render() {
        if (this._d) {
          this._d = false;
          this._p();
        }

        render(offscreenCanvas);
      },

      /**
       * Render a specific layer by name.
       * @memberof TileEngine
       * @function renderLayer
       *
       * @param {String} name - Name of the layer to render.
       */
      renderLayer(name) {
        let canvas = layerCanvases[name];
        let layer = layerMap[name];

        if (!canvas) {
          // cache the rendered layer so we can render it again without redrawing
          // all tiles
          canvas = document.createElement('canvas');
          canvas.width = mapwidth;
          canvas.height = mapheight;

          layerCanvases[name] = canvas;
          tileEngine._r(layer, canvas.getContext('2d'));
        }

        render(canvas);
      },

      /**
       * Check if the object collides with the layer (shares a gird coordinate with any positive tile index in layers data). The object being checked must have the properties `x`, `y`, `width`, and `height` so that its position in the grid can be calculated. kontra.Sprite defines these properties for you.
       *
       * ```js
       * import { TileEngine, Sprite } from 'kontra';
       *
       * let tileEngine = TileEngine({
       *   tilewidth: 32,
       *   tileheight: 32,
       *   width: 4,
       *   height: 4,
       *   tilesets: [{
       *     // ...
       *   }],
       *   layers: [{
       *     name: 'collision',
       *     data: [ 0,0,0,0,
       *             0,1,4,0,
       *             0,2,5,0,
       *             0,0,0,0 ]
       *   }]
       * });
       *
       * let sprite = Sprite({
       *   x: 50,
       *   y: 20,
       *   width: 5,
       *   height: 5
       * });
       *
       * tileEngine.layerCollidesWith('collision', sprite);  //=> false
       *
       * sprite.y = 28;
       *
       * tileEngine.layerCollidesWith('collision', sprite);  //=> true
       * ```
       * @memberof TileEngine
       * @function layerCollidesWith
       *
       * @param {String} name - The name of the layer to check for collision.
       * @param {Object} object - Object to check collision against.
       *
       * @returns {boolean} `true` if the object collides with a tile, `false` otherwise.
       */
      layerCollidesWith(name, object) {
        let x = object.x;
        let y = object.y;
        if (object.anchor) {
          x -= object.width * object.anchor.x;
          y -= object.height * object.anchor.y;
        }

        let row = getRow(y);
        let col = getCol(x);
        let endRow = getRow(y + object.height);
        let endCol = getCol(x + object.width);

        let layer = layerMap[name];

        // check all tiles
        for (let r = row; r <= endRow; r++) {
          for (let c = col; c <= endCol; c++) {
            if (layer.data[c + r * this.width]) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Get the tile at the specified layer using either x and y coordinates or row and column coordinates.
       *
       * ```js
       * import { TileEngine } from 'kontra';
       *
       * let tileEngine = TileEngine({
       *   tilewidth: 32,
       *   tileheight: 32,
       *   width: 4,
       *   height: 4,
       *   tilesets: [{
       *     // ...
       *   }],
       *   layers: [{
       *     name: 'collision',
       *     data: [ 0,0,0,0,
       *             0,1,4,0,
       *             0,2,5,0,
       *             0,0,0,0 ]
       *   }]
       * });
       *
       * tileEngine.tileAtLayer('collision', {x: 50, y: 50});  //=> 1
       * tileEngine.tileAtLayer('collision', {row: 2, col: 1});  //=> 2
       * ```
       * @memberof TileEngine
       * @function tileAtLayer
       *
       * @param {String} name - Name of the layer.
       * @param {Object} position - Position of the tile in either {x, y} or {row, col} coordinates.
       *
       * @returns {Number} The tile index. Will return `-1` if no layer exists by the provided name.
       */
      tileAtLayer(name, position) {
        let row = position.row || getRow(position.y);
        let col = position.col || getCol(position.x);

        if (layerMap[name]) {
          return layerMap[name].data[col + row * tileEngine.width];
        }

        return -1;
      },

      /**
       * Set the tile at the specified layer using either x and y coordinates or row and column coordinates.
       *
       * ```js
       * import { TileEngine } from 'kontra';
       *
       * let tileEngine = TileEngine({
       *   tilewidth: 32,
       *   tileheight: 32,
       *   width: 4,
       *   height: 4,
       *   tilesets: [{
       *     // ...
       *   }],
       *   layers: [{
       *     name: 'collision',
       *     data: [ 0,0,0,0,
       *             0,1,4,0,
       *             0,2,5,0,
       *             0,0,0,0 ]
       *   }]
       * });
       *
       * tileEngine.setTileAtLayer('collision', {row: 2, col: 1}, 10);
       * tileEngine.tileAtLayer('collision', {row: 2, col: 1});  //=> 10
       * ```
       * @memberof TileEngine
       * @function setTileAtLayer
       *
       * @param {String} name - Name of the layer.
       * @param {Object} position - Position of the tile in either {x, y} or {row, col} coordinates.
       * @param {Number} tile - Tile index to set.
       */
      setTileAtLayer(name, position, tile) {
        let row = position.row || getRow(position.y);
        let col = position.col || getCol(position.x);

        if (layerMap[name]) {
          this._d = true;
          layerMap[name].data[col + row * tileEngine.width] = tile;
        }
      },

      /**
      * Set the data at the specified layer.
      * 
      * ```js
      * import { TileEngine } from 'kontra';
      *
      * let tileEngine = TileEngine({
      *   tilewidth: 32,
      *   tileheight: 32,
      *   width: 2,
      *   height: 2,
      *   tilesets: [{
      *     // ...
      *   }],
      *   layers: [{
      *     name: 'collision',
      *     data: [ 0,1,
      *             2,3 ]
      *   }]
      * });
      *
      * tileEngine.setLayer('collision', [ 4,5,6,7]);
      * tileEngine.tileAtLayer('collision', {row: 0, col: 0});  //=> 4
      * tileEngine.tileAtLayer('collision', {row: 0, col: 1});  //=> 5
      * tileEngine.tileAtLayer('collision', {row: 1, col: 0});  //=> 6
      * tileEngine.tileAtLayer('collision', {row: 1, col: 1});  //=> 7
      * ```
      * 
      * @memberof TileEngine
      * @function setLayer
      * 
      * @param {String} name - Name of the layer.
      * @param {Number[]} data - 1D array of tile indices.
      */
      setLayer(name, data) {
        if (layerMap[name]) {
          this._d = true;
          layerMap[name].data = data;
        }
        if (layerCanvases[name]) {
          delete layerCanvases[name];
        }
      },



      /**
       * Add an object to the tile engine. The tile engine will set the objects camera position (`sx`, `sy`) to be in sync with the tile engine camera. kontra.Sprite uses this information to draw the sprite to the correct position on the canvas.
       * @memberof TileEngine
       * @function addObject
       *
       * @param {Object} object - Object to add to the tile engine.
       */
      addObject(object) {
        objects.push(object);
        object.sx = this._sx;
        object.sy = this._sy;
      },

      /**
       * Remove an object from the tile engine.
       * @memberof TileEngine
       * @function removeObject
       *
       * @param {Object} object - Object to remove from the tile engine.
       */
      removeObject(object) {
        let index = objects.indexOf(object);
        if (index !== -1) {
          objects.splice(index, 1);
          object.sx = object.sy = 0;
        }
      },

      // expose for testing
      _r: renderLayer,
      _p: prerender,

      // @if DEBUG
      layerCanvases: layerCanvases
      // @endif
    }, properties);

    // resolve linked files (source, image)
    tileEngine.tilesets.map(tileset => {
      // get the url of the Tiled JSON object (in this case, the properties object)
      let url = (window.__k ? window.__k.dm.get(properties) : '') || window.location.href;

      if (tileset.source) {
        // @if DEBUG
        if (!window.__k) {
          throw Error(`You must use "load" or "loadData" to resolve tileset.source`);
        }
        // @endif

        let source = window.__k.d[window.__k.u(tileset.source, url)];

        // @if DEBUG
        if (!source) {
          throw Error(`You must load the tileset source "${tileset.source}" before loading the tileset`);
        }
        // @endif

        Object.keys(source).map(key => {
          tileset[key] = source[key];
        });
      }

      if (''+tileset.image === tileset.image) {
        // @if DEBUG
        if (!window.__k) {
          throw Error(`You must use "load" or "loadImage" to resolve tileset.image`);
        }
        // @endif

        let image = window.__k.i[window.__k.u(tileset.image, url)];

        // @if DEBUG
        if (!image) {
          throw Error(`You must load the image "${tileset.image}" before loading the tileset`);
        }
        // @endif

        tileset.image = image;
      }
    });

    /**
     * Get the row from the y coordinate.
     * @private
     *
     * @param {Number} y - Y coordinate.
     *
     * @return {Number}
     */
    function getRow(y) {
      return y / tileEngine.tileheight | 0;
    }

    /**
     * Get the col from the x coordinate.
     * @private
     *
     * @param {Number} x - X coordinate.
     *
     * @return {Number}
     */
    function getCol(x) {
      return x / tileEngine.tilewidth | 0;
    }

    /**
     * Render a layer.
     * @private
     *
     * @param {Object} layer - Layer data.
     * @param {Context} context - Context to draw layer to.
     */
    function renderLayer(layer, context) {
      context.save();
      context.globalAlpha = layer.opacity;

      layer.data.map((tile, index) => {

        // skip empty tiles (0)
        if (!tile) return;

        // find the tileset the tile belongs to
        // assume tilesets are ordered by firstgid
        let tileset;
        for (let i = tileEngine.tilesets.length-1; i >= 0; i--) {
          tileset = tileEngine.tilesets[i];

          if (tile / tileset.firstgid >= 1) {
            break;
          }
        }

        let tilewidth = tileset.tilewidth || tileEngine.tilewidth;
        let tileheight = tileset.tileheight || tileEngine.tileheight;
        let margin = tileset.margin || 0;

        let image = tileset.image;

        let offset = tile - tileset.firstgid;
        let cols = tileset.columns ||
          image.width / (tilewidth + margin) | 0;

        let x = (index % tileEngine.width) * tilewidth;
        let y = (index / tileEngine.width | 0) * tileheight;
        let sx = (offset % cols) * (tilewidth + margin);
        let sy = (offset / cols | 0) * (tileheight + margin);

        context.drawImage(
          image,
          sx, sy, tilewidth, tileheight,
          x, y, tilewidth, tileheight
        );
      });

      context.restore();
    }

    /**
     * Pre-render the tiles to make drawing fast.
     * @private
     */
    function prerender() {
      if (tileEngine.layers) {
        tileEngine.layers.map(layer => {
          layerMap[layer.name] = layer;

          if (layer.visible !== false) {
            tileEngine._r(layer, offscreenContext);
          }
        });
      }
    }

    /**
     * Render a tile engine canvas.
     * @private
     *
     * @param {HTMLCanvasElement} canvas - Tile engine canvas to draw.
     */
    function render(canvas) {
      const { width, height } = getCanvas();
      const sWidth = Math.min(canvas.width, width);
      const sHeight = Math.min(canvas.height, height);

      tileEngine.context.drawImage(
        canvas,
        tileEngine.sx, tileEngine.sy, sWidth, sHeight,
        0, 0, sWidth, sHeight
      );
    }

    prerender();
    return tileEngine;
  }

  const VERSION = '0.0.2 (WORK-IN-PROGRESS)';

  const SCREEN_WIDTH = 640;
  const SCREEN_HEIGHT = 480;

  const TILE_WIDTH = 32;
  const TILE_HEIGHT = 32;

  const MAP_WIDTH = SCREEN_WIDTH / TILE_WIDTH;
  const MAP_HEIGHT = SCREEN_HEIGHT / TILE_HEIGHT;

  const TILE_SHEET_WIDTH = 8;
  const TILE_SHEET_HEIGHT = 9;

  const START_TILE = 64;
  const FINISH_TILE = 65;

  const SEED = 12;

  const palette = [
    '#000', // 0
    // '#00a', // 1
    '#367db1', // 1
    // '#0a0', // 2
    '#6c8300', // 2
    '#0aa', // 3
    '#a00', // 4
    // '#a0a', // 5
    '#cda90a', // 5
    // '#a50', // 6
    '#8bc89e', // 6
    '#aaa', // 7
    '#555', // 8
    '#55f', // 9
    '#5f5', // 10
    '#5ff', // 11
    '#f55', // 12
    // '#f5f', // 13
    '#e5e428', // 13
    // '#ff5', // 14
    '#829321', // 14
    // eslint-disable-next-line no-multi-spaces
    '#fff'  // 15
  ];

  const c = {
    black: 0,
    blue: 1,
    green: 2,
    cyan: 3,
    red: 4,
    magenta: 5,
    brown: 6,
    white: 7,
    'light-gray': 7,
    'dark-gray': 8,
    'bright-black': 8,
    'bright-blue': 9,
    'bright-green': 10,
    'bright-cyan': 11,
    'bright-red': 12,
    'bright-magenta': 13,
    'bright-yellow': 14,
    'bright-white': 15
  };

  function makeCoinSprite (context, tileEngine) {
    return spriteFactory({
      width: TILE_WIDTH / 2,
      height: TILE_HEIGHT / 2,

      x: 0,
      y: 0,

      render () {
        const { height, width } = this;

        const x = Math.floor(this.x);
        const y = Math.floor(this.y);

        context.fillStyle = palette[c['bright-magenta']];
        context.fillRect(x - tileEngine.sx + width / 4 + 2, y - tileEngine.sy + height / 4, width - 4, height);
        context.fillRect(x - tileEngine.sx + width / 4, y - tileEngine.sy + height / 4 + 2, width, height - 4);
        context.fillStyle = palette[c.magenta];
        context.fillRect(x - tileEngine.sx + width / 4 + 2, y - tileEngine.sy + height / 4 + 2, width - 4, height - 4);

        context.fillStyle = 'rgba(0,0,0,.35)';
        context.fillRect(x - tileEngine.sx + width / 4 + 1, y - tileEngine.sy + height / 4 + height + 1,
          width - 2, 1);
      }
    })
  }

  function makeEnemySprite (context, tileEngine) {
    const { tileheight, tilewidth } = tileEngine;

    return spriteFactory({
      width: tilewidth / 4 * 3,
      height: tileheight / 4 * 3,

      x: 0,
      y: 0,

      render () {
        const { height, width } = this;

        const x = Math.floor(this.x);
        const y = Math.floor(this.y);

        context.fillStyle = palette[c.black];
        context.fillRect(x - tileEngine.sx, y - tileEngine.sy, width, height - 3);

        // eyes
        context.fillStyle = palette[c['bright-red']];
        context.fillRect(x - tileEngine.sx + width / 8 * 1, y + 4, 6, 4);
        context.fillRect(x - tileEngine.sx + width / 8 * 5, y + 4, 6, 4);
        context.fillStyle = palette[c.black];
        context.fillRect(x - tileEngine.sx + width / 8 * 1 + 2, y + 4 + 2, 2, 2);
        context.fillRect(x - tileEngine.sx + width / 8 * 5 + 2, y + 4 + 2, 2, 2);

        context.fillStyle = 'rgba(0,0,0,.35)';
        context.fillRect(x - tileEngine.sx + 1, y - tileEngine.sy + height - 2,
          width - 2, 2);
      }
    })
  }

  const CHARACTER_WIDTH = 4;
  const CHARACTER_HEIGHT = 6;

  // https://robey.lag.net/2010/01/23/tiny-monospace-font.html
  const font = [
    [
      // SPACE
      //
      // 0000
      // 0000
      // 0000
      // 0000
      // 0000
      // 0000
      0x00,
      0x00,
      0x00,
      0x00,
      0x00,
      0x00
    ],
    [
      // !
      //
      // 0100
      // 0100
      // 0100
      // 0000
      // 0100
      // 0000
      0x04,
      0x04,
      0x04,
      0x00,
      0x04,
      0x00
    ],
    [
      // "
      //
      // 1010
      // 1010
      // 0000
      // 0000
      // 0000
      // 0000
      0x0a,
      0x0a,
      0x00,
      0x00,
      0x00,
      0x00
    ],
    [
      // #
      //
      // 1010
      // 1110
      // 1010
      // 1110
      // 1010
      // 0000
      0x0a,
      0x0e,
      0x0a,
      0x0e,
      0x0a,
      0x00
    ],
    [
      // $
      //
      // 0110
      // 1100
      // 0110
      // 1100
      // 0100
      // 0000
      0x06,
      0x0c,
      0x06,
      0x0c,
      0x04,
      0x00
    ],
    [
      // %
      //
      // 1000
      // 0010
      // 0100
      // 1000
      // 0010
      // 0000
      0x08,
      0x02,
      0x04,
      0x08,
      0x02,
      0x00
    ],
    [
      // &
      //
      // 1100
      // 1100
      // 1110
      // 1010
      // 0110
      // 0000
      0x0c,
      0x0c,
      0x0e,
      0x0a,
      0x06,
      0x00
    ],
    [
      // '
      //
      // 0100
      // 0100
      // 0000
      // 0000
      // 0000
      // 0000
      0x04,
      0x04,
      0x00,
      0x00,
      0x00,
      0x00
    ],
    [
      // (
      //
      // 0010
      // 0100
      // 0100
      // 0100
      // 0010
      // 0000
      0x02,
      0x04,
      0x04,
      0x04,
      0x02,
      0x00
    ],
    [
      // )
      //
      // 1000
      // 0100
      // 0100
      // 0100
      // 1000
      // 0000
      0x08,
      0x04,
      0x04,
      0x04,
      0x08,
      0x00
    ],
    [
      // *
      //
      // 1010
      // 0100
      // 1010
      // 0000
      // 0000
      // 0000
      0x0a,
      0x04,
      0x0a,
      0x00,
      0x00,
      0x00
    ],
    [
      // +
      //
      // 0000
      // 0100
      // 1110
      // 0100
      // 0000
      // 0000
      0x00,
      0x04,
      0x0e,
      0x04,
      0x00,
      0x00
    ],
    [
      // ,
      //
      // 0000
      // 0000
      // 0000
      // 0100
      // 1000
      // 0000
      0x00,
      0x00,
      0x00,
      0x04,
      0x08,
      0x00
    ],
    [
      // -
      //
      // 0000
      // 0000
      // 1110
      // 0000
      // 0000
      // 0000
      0x00,
      0x00,
      0x0e,
      0x00,
      0x00,
      0x00
    ],
    [
      // .
      //
      // 0000
      // 0000
      // 0000
      // 0000
      // 0100
      // 0000
      0x00,
      0x00,
      0x00,
      0x00,
      0x04,
      0x00
    ],
    [
      // /
      //
      // 0010
      // 0010
      // 0100
      // 1000
      // 1000
      // 0000
      0x02,
      0x02,
      0x04,
      0x08,
      0x08,
      0x00
    ],
    [
      // 0
      //
      // 0110
      // 1010
      // 1010
      // 1010
      // 1100
      // 0000
      0x06,
      0x0a,
      0x0a,
      0x0a,
      0x0c,
      0x00
    ],
    [
      // 1
      //
      // 0100
      // 1100
      // 0100
      // 0100
      // 0100
      // 0000
      0x04,
      0x0c,
      0x04,
      0x04,
      0x04,
      0x00
    ],
    [
      // 2
      //
      // 1100
      // 0010
      // 0100
      // 1000
      // 1110
      // 0000
      0x0c,
      0x02,
      0x04,
      0x08,
      0x0e,
      0x00
    ],
    [
      // 3
      //
      // 1100
      // 0010
      // 0100
      // 0010
      // 1100
      // 0000
      0x0c,
      0x02,
      0x04,
      0x02,
      0x0c,
      0x00
    ],
    [
      // 4
      //
      // 1010
      // 1010
      // 1110
      // 0010
      // 0010
      // 0000
      0x0a,
      0x0a,
      0x0e,
      0x02,
      0x02,
      0x00
    ],
    [
      // 5
      //
      // 1110
      // 1000
      // 1100
      // 0010
      // 1100
      // 0000
      0x0e,
      0x08,
      0x0c,
      0x02,
      0x0c,
      0x00
    ],
    [
      // 6
      //
      // 0110
      // 1000
      // 1110
      // 1010
      // 1110
      // 0000
      0x06,
      0x08,
      0x0e,
      0x0a,
      0x0e,
      0x00
    ],
    [
      // 7
      //
      // 1110
      // 0010
      // 0100
      // 1000
      // 1000
      // 0000
      0x0e,
      0x02,
      0x04,
      0x08,
      0x08,
      0x00
    ],
    [
      // 8
      //
      // 1110
      // 1010
      // 1110
      // 1010
      // 1110
      // 0000
      0x0e,
      0x0a,
      0x0e,
      0x0a,
      0x0e,
      0x00
    ],
    [
      // 9
      //
      // 1110
      // 1010
      // 1110
      // 0010
      // 1100
      // 0000
      0x0e,
      0x0a,
      0x0e,
      0x02,
      0x0c,
      0x00
    ],
    [
      // :
      //
      // 0000
      // 0100
      // 0000
      // 0100
      // 0000
      // 0000
      0x00,
      0x04,
      0x00,
      0x04,
      0x00,
      0x00
    ],
    [
      // ;
      //
      // 0000
      // 0100
      // 0000
      // 0100
      // 1000
      // 0000
      0x00,
      0x04,
      0x00,
      0x04,
      0x08,
      0x00
    ],
    [
      // <
      //
      // 0010
      // 0100
      // 1000
      // 0100
      // 0010
      // 0000
      0x02,
      0x04,
      0x08,
      0x04,
      0x02,
      0x00
    ],
    [
      // =
      //
      // 0000
      // 1110
      // 0000
      // 1110
      // 0000
      // 0000
      0x00,
      0x0e,
      0x00,
      0x0e,
      0x00,
      0x00
    ],
    [
      // >
      //
      // 1000
      // 0100
      // 0010
      // 0100
      // 1000
      // 0000
      0x08,
      0x04,
      0x02,
      0x04,
      0x08,
      0x00
    ],
    [
      // ?
      //
      // 1110
      // 0010
      // 0100
      // 0000
      // 0100
      // 0000
      0x0e,
      0x02,
      0x04,
      0x00,
      0x04,
      0x00
    ],
    [
      // @
      //
      // 0100
      // 1010
      // 1110
      // 1000
      // 0110
      // 0000
      0x04,
      0x0a,
      0x0e,
      0x08,
      0x06,
      0x00
    ],
    [
      // A
      //
      // 0100
      // 1010
      // 1110
      // 1010
      // 1010
      // 0000
      0x04,
      0x0a,
      0x0e,
      0x0a,
      0x0a,
      0x00
    ],
    [
      // B
      //
      // 1100
      // 1010
      // 1100
      // 1010
      // 1100
      // 0000
      0x0c,
      0x0a,
      0x0c,
      0x0a,
      0x0c,
      0x00
    ],
    [
      // C
      //
      // 0110
      // 1000
      // 1000
      // 1000
      // 0110
      // 0000
      0x06,
      0x08,
      0x08,
      0x08,
      0x06,
      0x00
    ],
    [
      // D
      //
      // 1100
      // 1010
      // 1010
      // 1010
      // 1100
      // 0000
      0x0c,
      0x0a,
      0x0a,
      0x0a,
      0x0c,
      0x00
    ],
    [
      // E
      //
      // 1110
      // 1000
      // 1110
      // 1000
      // 1110
      // 0000
      0x0e,
      0x08,
      0x0e,
      0x08,
      0x0e,
      0x00
    ],
    [
      // F
      //
      // 1110
      // 1000
      // 1110
      // 1000
      // 1000
      // 0000
      0x0e,
      0x08,
      0x0e,
      0x08,
      0x08,
      0x00
    ],
    [
      // G
      //
      // 0110
      // 1000
      // 1110
      // 1010
      // 0110
      // 0000
      0x06,
      0x08,
      0x0e,
      0x0a,
      0x06,
      0x00
    ],
    [
      // H
      //
      // 1010
      // 1010
      // 1110
      // 1010
      // 1010
      // 0000
      0x0a,
      0x0a,
      0x0e,
      0x0a,
      0x0a,
      0x00
    ],
    [
      // I
      //
      // 1110
      // 0100
      // 0100
      // 0100
      // 1110
      // 0000
      0x0e,
      0x04,
      0x04,
      0x04,
      0x0e,
      0x00
    ],
    [
      // J
      //
      // 0010
      // 0010
      // 0010
      // 1010
      // 0100
      // 0000
      0x02,
      0x02,
      0x02,
      0x0a,
      0x04,
      0x00
    ],
    [
      // K
      //
      // 1010
      // 1010
      // 1100
      // 1010
      // 1010
      // 0000
      0x0a,
      0x0a,
      0x0c,
      0x0a,
      0x0a,
      0x00
    ],
    [
      // L
      //
      // 1000
      // 1000
      // 1000
      // 1000
      // 1110
      // 0000
      0x08,
      0x08,
      0x08,
      0x08,
      0x0f,
      0x00
    ],
    [
      // M
      //
      // 1010
      // 1110
      // 1110
      // 1010
      // 1010
      // 0000
      0x0a,
      0x0e,
      0x0e,
      0x0a,
      0x0a,
      0x00
    ],
    [
      // N
      //
      // 1010
      // 1110
      // 1110
      // 1110
      // 1010
      // 0000
      0x0a,
      0x0e,
      0x0e,
      0x0e,
      0x0a,
      0x00
    ],
    [
      // O
      //
      // 0100
      // 1010
      // 1010
      // 1010
      // 0100
      // 0000
      0x04,
      0x0a,
      0x0a,
      0x0a,
      0x04,
      0x00
    ],
    [
      // P
      //
      // 1100
      // 1010
      // 1100
      // 1000
      // 1000
      // 0000
      0x0c,
      0x0a,
      0x0c,
      0x08,
      0x08,
      0x00
    ],
    [
      // Q
      //
      // 0100
      // 1010
      // 1010
      // 1110
      // 0110
      // 0000
      0x04,
      0x0a,
      0x0a,
      0x0e,
      0x06,
      0x00
    ],
    [
      // R
      //
      // 1100
      // 1010
      // 1110
      // 1100
      // 1010
      // 0000
      0x0c,
      0x0a,
      0x0e,
      0x0c,
      0x0a,
      0x00
    ],
    [
      // S
      //
      // 0110
      // 1000
      // 0100
      // 0010
      // 1100
      // 0000
      0x06,
      0x08,
      0x04,
      0x02,
      0x0c,
      0x00
    ],
    [
      // T
      //
      // 1110
      // 0100
      // 0100
      // 0100
      // 0100
      // 0000
      0x0e,
      0x04,
      0x04,
      0x04,
      0x04,
      0x00
    ],
    [
      // U
      //
      // 1010
      // 1010
      // 1010
      // 1010
      // 0110
      // 0000
      0x0a,
      0x0a,
      0x0a,
      0x0a,
      0x06,
      0x00
    ],
    [
      // V
      //
      // 1010
      // 1010
      // 1010
      // 0100
      // 0100
      // 0000
      0x0a,
      0x0a,
      0x0a,
      0x04,
      0x04,
      0x00
    ],
    [
      // W
      //
      // 1010
      // 1010
      // 1110
      // 1110
      // 1010
      // 0000
      0x0a,
      0x0a,
      0x0e,
      0x0e,
      0x0a,
      0x00
    ],
    [
      // X
      //
      // 1010
      // 1010
      // 0100
      // 1010
      // 1010
      // 0000
      0x0a,
      0x0a,
      0x04,
      0x0a,
      0x0a,
      0x00
    ],
    [
      // Y
      //
      // 1010
      // 1010
      // 0100
      // 0100
      // 0100
      // 0000
      0x0a,
      0x0a,
      0x04,
      0x04,
      0x04,
      0x00
    ],
    [
      // Z
      //
      // 1110
      // 0010
      // 0100
      // 1000
      // 1110
      // 0000
      0x0e,
      0x02,
      0x04,
      0x08,
      0x0e,
      0x00
    ],
    [
      // [
      //
      // 1110
      // 1000
      // 1000
      // 1000
      // 1110
      // 0000
      0x0e,
      0x08,
      0x08,
      0x08,
      0x0e,
      0x00
    ],
    [
      // \
      //
      // 0000
      // 1000
      // 0100
      // 0010
      // 0000
      // 0000
      0x00,
      0x08,
      0x04,
      0x02,
      0x00,
      0x00
    ],
    [
      // ]
      //
      // 1110
      // 0010
      // 0010
      // 0010
      // 1110
      // 0000
      0x0e,
      0x02,
      0x02,
      0x02,
      0x0e,
      0x00
    ],
    [
      // ^
      //
      // 0100
      // 1010
      // 0000
      // 0000
      // 0000
      // 0000
      0x04,
      0x0a,
      0x00,
      0x00,
      0x00,
      0x00
    ],
    [
      // _
      //
      // 0000
      // 0000
      // 0000
      // 0000
      // 1110
      // 0000
      0x00,
      0x00,
      0x00,
      0x00,
      0x0e,
      0x00
    ]
  ];

  function makeFontSprite () {
    const canvas = document.createElement('canvas');

    canvas.width = font.length * CHARACTER_WIDTH;
    canvas.height = CHARACTER_HEIGHT;

    const context = canvas.getContext('2d');

    font.forEach((character, index) => {
      for (let y = 0; y < CHARACTER_HEIGHT; ++y) {
        let mask = 0x08;

        for (let x = 0; x < CHARACTER_WIDTH; ++x, mask >>= 1) {
          const bit = character[y] & mask;

          const color = bit ? palette[c['bright-white']] : palette[c.black];

          context.fillStyle = color;
          context.fillRect(index * CHARACTER_WIDTH + x, y, 1, 1);
        }
      }
    });

    return spriteFactory({
      width: canvas.width,
      height: canvas.height,

      x: 0,
      y: 0,

      image: canvas,

      outputCharacterXY (x, y, character) {
        const sx = (character.charCodeAt(0) - ' '.charCodeAt(0)) * CHARACTER_WIDTH;

        this.context.drawImage(this.image,
          sx, 0, CHARACTER_WIDTH, CHARACTER_HEIGHT,
          x, y, CHARACTER_WIDTH, CHARACTER_HEIGHT
        );
      },

      outputText (text) {
        text.split('').forEach((character, index) => {
          this.outputCharacterXY(this.x + index * CHARACTER_WIDTH, this.y, character);
        });
      }
    })
  }

  /* Autogenerated by rollup-plugin-make-levels; do NOT edit! */

  const levels = [
    /*
      Level 1 (0)

      ....................
      ....................
      ....................
      ....@@@@.....@@@....
      ...@@@@@@..@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@.....
      ...@@@@@@@@@@@@.....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ....@@......@@@.....
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16, 50, 58, 42, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 60, 42, 16, 16, 50, 58, 61, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 60, 58, 58, 61, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 49, 28, 28, 28, 28, 28, 28, 57, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 20, 16, 16, 16, 16, 16, 16, 23, 28, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 2 (1)

      ....................
      ....................
      ....................
      .........@@@........
      ........@@@@@@@.....
      ........@@@@@@@@....
      ........@@@@@@@@@...
      .......@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@....
      ....@@@@@@@@........
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 42, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 50, 61, 62, 60, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16,
        16, 16, 16, 50, 58, 58, 58, 61, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 49, 28, 28, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 28, 20, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 3 (2)

      ....................
      ....................
      ......@@@@@@@@......
      .....@@@@@@@@@@@....
      .....@@@@@@@@@@@@...
      .....@@@@@@@@@@@@...
      ......@@@....@@@@...
      ..............@@@...
      ..............@@@...
      .............@@@@...
      .............@@@@...
      ..............@@....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 50, 58, 58, 58, 58, 58, 58, 42, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 60, 58, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 16, 23, 57, 62, 49, 28, 28, 28, 28, 57, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 23, 28, 20, 16, 16, 16, 16, 23, 57, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 52, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 52, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 61, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 57, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 4 (3)

      ....................
      ....................
      ..............@@....
      ............@@@@@...
      ......@@..@@@@@@@...
      .....@@@@@@@@@@@@@..
      ....@@@@@@@@@@@@@@..
      ....@@@@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 61, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 50, 42, 16, 16, 50, 58, 61, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 61, 60, 58, 58, 61, 62, 62, 62, 62, 62, 60, 42, 16, 16,
        16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 5 (5)

      ....................
      ....................
      ...@@@@@@@..........
      ..@@@@@@@@@.........
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      .....@@@@@@@@@@@....
      ......@@@@@@@@@@....
      ......@@@@@...@@....
      .......@@...........
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 50, 58, 58, 58, 58, 58, 42, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 50, 61, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 60, 58, 58, 58, 58, 58, 42, 16, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 23, 28, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 52, 62, 62, 62, 49, 28, 28, 28, 57, 44, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 23, 57, 49, 28, 20, 16, 16, 16, 23, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 23, 20, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 6 (6)

      ....................
      ....................
      ........@@..........
      ......@@@@@..@@@....
      ....@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@..@@@....
      ...@@@..............
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 50, 58, 61, 60, 42, 16, 16, 50, 58, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 61, 62, 62, 62, 60, 58, 58, 61, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 49, 28, 28, 57, 62, 49, 20, 16, 16, 16,
        16, 16, 23, 57, 62, 49, 28, 28, 28, 28, 20, 16, 16, 23, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 23, 28, 20, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 7 (8)

      ....................
      ....................
      ...........@@@@.....
      ....@@@...@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@@..
      ..@@@@@@@@@@@..@@@..
      ..@@@@@@@@@@@...@...
      ..@@@@...@@@@.......
      ...@@.....@@........
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 42, 16, 16, 16, 50, 61, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 60, 58, 58, 58, 61, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 28, 28, 57, 60, 42, 16, 16,
        16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 23, 41, 20, 16, 16,
        16, 16, 52, 62, 62, 49, 28, 28, 28, 57, 62, 62, 44, 16, 16, 16, 17, 16, 16, 16,
        16, 16, 23, 57, 49, 20, 16, 16, 16, 23, 57, 49, 20, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 23, 20, 16, 16, 16, 16, 16, 23, 20, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 8 (9)

      ....................
      ....................
      ....................
      .....@@....@@@@.....
      ....@@@@@@@@@@@@....
      ....@@@@@@@@@@@@....
      ...@@@@@@@@@@@@.....
      ...@@@@@@@@@@@@.....
      ...@@@@@@@@@@@@.....
      ...@@@@@@@@@@@@.....
      ....@@@@@@@@@@@.....
      .......@@@@@@@......
      ...........@@.......
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 61, 60, 58, 58, 58, 58, 61, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 57, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 23, 28, 28, 28, 57, 49, 20, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 20, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 9 (10)

      ....................
      ....................
      .....@@@@@@.........
      ....@@@@@@@@........
      ...@@@@@@@@@@@@@....
      ..@@@@@@@@@@@@@@@...
      ..@@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      .....@@@@@@@@@@@@@..
      ...........@@@@@@@..
      ............@@@@@...
      .............@@@....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 58, 58, 58, 58, 42, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 60, 58, 58, 58, 42, 16, 16, 16, 16,
        16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 23, 28, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 57, 62, 62, 62, 62, 60, 42, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 57, 62, 62, 62, 49, 20, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 57, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 10 (11)

      ....................
      ....................
      ....................
      ...@@......@@@@.....
      ..@@@@....@@@@@@....
      ..@@@@....@@@@@@....
      ..@@@@....@@@@@@....
      ..@@@@...@@@@@@.....
      ...@@@...@@@@@......
      ...@@@@@@@@@@.......
      ...@@@@@@@@@@.......
      ....@@@@@@@@........
      ......@@@@@.........
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 50, 42, 16, 16, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 50, 61, 60, 42, 16, 16, 16, 16, 50, 61, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 52, 62, 62, 44, 16, 16, 16, 16, 52, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 52, 62, 62, 44, 16, 16, 16, 16, 52, 62, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 23, 57, 62, 44, 16, 16, 16, 50, 61, 62, 62, 49, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 44, 16, 16, 16, 52, 62, 62, 49, 20, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 60, 58, 58, 58, 61, 62, 62, 44, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 57, 62, 62, 62, 49, 20, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 23, 28, 28, 28, 20, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 11 (12)

      ....................
      ....................
      ..........@@@@......
      ........@@@@@@@@....
      ....@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@@...
      ....@@@@..@@@@@@@...
      .....@@...@@@@@@@...
      ..........@@@@@@....
      ...........@@@@.....
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 61, 62, 62, 60, 58, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 58, 58, 61, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 49, 28, 28, 57, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 23, 57, 49, 20, 16, 16, 52, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 23, 20, 16, 16, 16, 52, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 57, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 28, 28, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 12 (13)

      ....................
      ....................
      ...........@@@@.....
      .....@@@@@@@@@@.....
      ....@@@@@@@@@@@.....
      ....@@@@@@@@@@......
      ....@@@@@@@@@@......
      ...@@@@@@@@@@@......
      ...@@@@@@@@@@@@.....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ....@@@@@@@@@@@.....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 58, 58, 58, 58, 58, 61, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 28, 28, 28, 28, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 13 (14)

      ....................
      ....................
      .....@@.............
      ....@@@@@@@@@@@@....
      ....@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@@..
      ....@@@@@@@@@@@@@@..
      ....@@@@@@@@@@@@@@..
      .....@@@@@@@@@@@@@..
      ......@@@@@@@@@@@...
      ........@@@@@@......
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 61, 60, 58, 58, 58, 58, 58, 58, 58, 58, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16,
        16, 16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16,
        16, 16, 16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16,
        16, 16, 16, 16, 16, 16, 23, 28, 57, 62, 62, 62, 62, 49, 28, 28, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 23, 28, 28, 28, 28, 20, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 14 (15)

      ....................
      ....................
      .........@@.........
      ........@@@@........
      ....@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@@..
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@@...
      ........@@@@@@@@@...
      ...........@@@@@....
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 50, 61, 60, 42, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 58, 58, 61, 62, 62, 60, 58, 58, 58, 58, 42, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 28, 57, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 23, 28, 28, 57, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 28, 28, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 15 (16)

      ....................
      ....................
      ..........@@........
      .........@@@@@......
      .........@@@@@@.....
      ..........@@@@@.....
      ..........@@@@@@....
      ....@@....@@@@@@@...
      ...@@@@..@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@....
      .....@@@@@..........
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 61, 60, 58, 42, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 57, 62, 62, 60, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 52, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 52, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 52, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 50, 61, 60, 42, 16, 16, 50, 61, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 60, 58, 58, 61, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 23, 57, 62, 62, 62, 49, 28, 28, 28, 28, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 23, 28, 28, 28, 20, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 16 (17)

      ....................
      ....................
      ...........@@@@.....
      ....@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@....
      ...@@@@@..@@@@@@....
      ....@@@.....@@@.....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 58, 58, 58, 58, 58, 61, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 49, 28, 28, 57, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 49, 20, 16, 16, 23, 28, 57, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 20, 16, 16, 16, 16, 16, 23, 28, 20, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 17 (19)

      ....................
      ....................
      ...........@@.......
      .........@@@@@@.....
      ........@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@.....
      ....@@@@@@@@@@@.....
      ....@@@@@@@@@@@.....
      ....@@@@@@@@@@@@....
      ....@@@@@@@@@@@@@...
      .....@@@@@@@@@@@@...
      ..............@@....
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 61, 60, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 50, 58, 58, 58, 58, 61, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 28, 28, 28, 57, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 23, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 18 (21)

      ....................
      ....................
      ....................
      ...........@@@@.....
      ....@.....@@@@@@....
      ...@@@....@@@@@@....
      ..@@@@...@@@@@@@....
      ..@@@@..@@@@@@@@....
      ..@@@@@@@@@@@@@.....
      ..@@@@@@@@@@@@......
      ...@@@@@@@@@@@......
      ....@@@@@@@@@.......
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 29, 16, 16, 16, 16, 16, 50, 61, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 50, 59, 42, 16, 16, 16, 16, 52, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 50, 61, 62, 44, 16, 16, 16, 50, 61, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 52, 62, 62, 44, 16, 16, 50, 61, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16,
        16, 16, 52, 62, 62, 60, 58, 58, 61, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16, 16,
        16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 28, 28, 20, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 19 (22)

      ....................
      ....................
      ....................
      ........@@@@@@@.....
      ......@@@@@@@@@@....
      ....@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@@...
      ...@@@@@@@@@@@@@@...
      ...@@@@@...@@@@@@...
      ....@@@.....@@@@....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 50, 58, 58, 58, 58, 58, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 50, 58, 61, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 58, 61, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 52, 62, 62, 62, 49, 28, 28, 28, 57, 62, 62, 62, 62, 44, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 49, 20, 16, 16, 16, 23, 57, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 20, 16, 16, 16, 16, 16, 23, 28, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    },

    /*
      Level 20 (24)

      ....................
      ....................
      ......@@@....@@.....
      .....@@@@@@@@@@@....
      ....@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@....
      ....@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@....
      ...@@@@@@@@@@@@@@...
      ....@@@@@@@@@@@@@...
      .......@@@@@@@@@....
      ....................
      ....................
      ....................
    */
    {
      collision: [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
      ],
      ground: [
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 50, 58, 42, 16, 16, 16, 16, 50, 42, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 50, 61, 62, 60, 58, 58, 58, 58, 61, 60, 42, 16, 16, 16, 16,
        16, 16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 16, 52, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 50, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 44, 16, 16, 16, 16,
        16, 16, 16, 23, 57, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 60, 42, 16, 16, 16,
        16, 16, 16, 16, 23, 28, 28, 57, 62, 62, 62, 62, 62, 62, 62, 49, 20, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 23, 28, 28, 28, 28, 28, 28, 28, 20, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
      ]
    }
  ];

  /* global zzfx */
  const intervalIDs = {};

  // Sound effects courtesy of Frank Force's Zuper Zmall Zeeded Zound Zynth...
  // ZzFX
  //
  // http://www.3d2k.com/js/zzfx/
  const sounds = {
    collect: [1, 0.1, 16, 0.5, 0.27, 0.6, 0, 6.6, 0.48], // ZzFX 80972
    collision: [1, 0.1, 726, 0.2, 0.1, 0, 1, 0, 0.37], // ZzFX 8269
    lose: [1, 0.1, 952, 0.4, 0.09, 1.3, 0, 0, 0.88], // ZzFX 18220
    'old-collision': [1, 0.1, 28, 0.4, 0.66, 0.8, 0.1, 0.3, 0.57], // ZzFX 10114
    sea: [1, 0.1, 15, 0.9, 0.44, 0, 3.6, 0.2, 0.89], // ZzFX 8720
    start: [1, 0.1, 968, 0.4, 0.56, 3.3, 0, 15.2, 0.32], // ZzFX 23427
    win: [1, 0.1, 652, 1.1, 0.94, 0, 3.5, 4.5, 0.15] // ZzFX 62086
  };

  const playSound = name => zzfx.apply(null, sounds[name]);

  function playSoundUnique (name) {
    if (!intervalIDs[name]) {
      zzfx.apply(null, sounds[name]);

      intervalIDs[name] = window.setInterval(function () {
        window.clearInterval(intervalIDs[name]);
        intervalIDs[name] = null;
      }, sounds[name][3] * 1000);
    }
  }

  function makePlayerSprite (context, tileEngine) {
    const { tileheight, tilewidth } = tileEngine;

    return spriteFactory({
      width: tilewidth / 4 * 3,
      height: tileheight / 4 * 3,

      x: 0,
      y: 0,

      render () {
        context.fillStyle = palette[c.red];
        context.fillRect(this.x - tileEngine.sx, this.y - tileEngine.sy, this.width,
          this.height - 3);

        // eyes
        context.fillStyle = palette[c['bright-white']];
        context.fillRect(this.x - tileEngine.sx + this.width / 8 * 1, this.y + 4, 6, 4);
        context.fillRect(this.x - tileEngine.sx + this.width / 8 * 5, this.y + 4, 6, 4);
        context.fillStyle = palette[c.black];
        context.fillRect(this.x - tileEngine.sx + this.width / 8 * 1 + 2, this.y + 4 + 2, 2, 2);
        context.fillRect(this.x - tileEngine.sx + this.width / 8 * 5 + 2, this.y + 4 + 2, 2, 2);

        context.fillStyle = 'rgba(0,0,0,.35)';
        context.fillRect(this.x - tileEngine.sx + 1, this.y - tileEngine.sy + this.height - 2,
          this.width - 2, 2);
      },

      moveEast () {
        const { height, width, y } = this;
        let { x } = this;

        if (x < tilewidth * tileEngine.width - 1 - width) {
          ++x;
        }

        if (!tileEngine.layerCollidesWith('collision', {
          height,
          width,
          x: x - tileEngine.sx,
          y: y - tileEngine.sy
        })) {
          this.x = x;
        } else {
          playSoundUnique('sea');
        }
      },

      moveNorth () {
        const { height, width, x } = this;
        let { y } = this;

        if (y > 0) {
          --y;
        }

        if (!tileEngine.layerCollidesWith('collision', {
          height,
          width,
          x: x - tileEngine.sx,
          y: y - tileEngine.sy
        })) {
          this.y = y;
        } else {
          playSoundUnique('sea');
        }
      },

      moveSouth () {
        const { height, width, x } = this;
        let { y } = this;

        if (y < tileheight * tileEngine.height - 1 - height) {
          ++y;
        }

        if (!tileEngine.layerCollidesWith('collision', {
          height,
          width,
          x: x - tileEngine.sx,
          y: y - tileEngine.sy
        })) {
          this.y = y;
        } else {
          playSoundUnique('sea');
        }
      },

      moveWest () {
        const { height, width, y } = this;
        let { x } = this;

        if (x > 0) {
          --x;
        }

        if (!tileEngine.layerCollidesWith('collision', {
          height,
          width,
          x: x - tileEngine.sx,
          y: y - tileEngine.sy
        })) {
          this.x = x;
        } else {
          playSoundUnique('sea');
        }
      }
    })
  }

  function random(seed) {
  	function _seed(s) {
  		if ((seed = (s|0) % 2147483647) <= 0) {
  			seed += 2147483646;
  		}
  	}

  	function _nextInt() {
  		return seed = seed * 48271 % 2147483647;
  	}

  	function _nextFloat() {
  		return (_nextInt() - 1) / 2147483646;
  	}

  	_seed(seed);

  	return {
  		seed: _seed,
  		nextInt: _nextInt,
  		nextFloat: _nextFloat
  	};
  }

  var fastRandom = random;

  const generator = fastRandom(SEED);

  const random$1 = generator.nextFloat;

  function makeResizeCanvas (canvas) {
    return function () {
      const { innerWidth, innerHeight } = window;
      const windowRatio = innerWidth / innerHeight;
      const canvasRatio = SCREEN_WIDTH / SCREEN_HEIGHT;

      if (windowRatio < canvasRatio) {
        canvas.style.width = innerWidth + 'px';
        canvas.style.height = (innerWidth / canvasRatio) + 'px';
      } else {
        canvas.style.width = (innerHeight * canvasRatio) + 'px';
        canvas.style.height = innerHeight + 'px';
      }
    }
  }

  const radiuses = [0.5, 1, 2, 4];

  function fillCircle (context, x, y, radius, color) {
    context.fillStyle = color;
    context.beginPath();
    context.arc(x, y, radius, 0, 2 * Math.PI);
    context.fill();
  }

  function makeTileSprite (options) {
    const N = 8;

    const canvas2 = document.createElement('canvas');

    canvas2.width = TILE_WIDTH;
    canvas2.height = TILE_HEIGHT;

    const context2 = canvas2.getContext('2d');

    return Object.assign(
      spriteFactory({
        width: TILE_WIDTH,
        height: TILE_HEIGHT,

        x: 0,
        y: 0,

        bkcolor: palette[c.black],

        circles: [],

        render () {
          const { bkcolor, context, height, width } = this;

          context2.fillStyle = bkcolor;
          context2.fillRect(0, 0, width, height);

          const offset = width / N / 2;

          this.circles.forEach(circle => {
            const radius = offset * radiuses[circle.radius];

            const cx = (circle.x + N / 2) * (width / N);
            const cy = (circle.y + N / 2) * (height / N);

            fillCircle(context2, offset + cx, offset + cy, radius, circle.color);
          });

          context.drawImage(canvas2, this.x, this.y);
        }
      }),
      options
    )
  }

  // xxx yyy rr cccc ????
  //
  // xxx: -4..3
  // yyy: -4..3
  // rr: 0.5, 1, 2, 4?
  //
  // cccc: 0..15
  // ????: ?
  const tiles = [
    {
      bkcolor: palette[c.black]
    },
    {
      bkcolor: palette[c.blue]
    },
    {
      bkcolor: palette[c.green]
    },
    {
      bkcolor: palette[c.cyan]
    },
    {
      bkcolor: palette[c.red]
    },
    {
      bkcolor: palette[c.magenta]
    },
    {
      bkcolor: palette[c.brown]
    },
    {
      bkcolor: palette[c.white]
    },
    {
      bkcolor: palette[c['dark-gray']]
    },
    {
      bkcolor: palette[c['bright-blue']]
    },
    {
      bkcolor: palette[c['bright-green']]
    },
    {
      bkcolor: palette[c['bright-cyan']]
    },
    {
      bkcolor: palette[c['bright-red']]
    },
    {
      bkcolor: palette[c['bright-magenta']]
    },
    {
      bkcolor: palette[c['bright-yellow']]
    },
    {
      bkcolor: palette[c['bright-white']]
    },
    { // autotile 0: sea
      bkcolor: palette[c.blue]
    },
    { // autotile 1: wet sand, cul-de-sac bottom
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 0,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 2: wet sand, cul-de-sac right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 0,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 3
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 4: sand, bottom-right
      bkcolor: palette[14],
      circles: [
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 0,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 5: wet sand, cul-de-sac left
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 6
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 7: sand, bottom-left
      bkcolor: palette[14],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 8
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 9
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 10
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 11
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 12: sand, bottom
      bkcolor: palette[14],
      circles: [
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 13: wet sand, cul-de-sac top
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 14
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 15
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 16
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 17: sand, right
      bkcolor: palette[14],
      circles: [
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 18
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 19
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 20
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 21: wet sand, bar top, dots bottom-left and bottom-right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 22
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 23
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 24: wet sand, corners top-left, bottom-left, bottom-right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 25: wet sand, dots bottom-left and bottom-right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 26: sand, top-right
      bkcolor: palette[14],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 27
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 28: sand, right
      bkcolor: palette[14],
      circles: [
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 29
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 30
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 31
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 32
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 33: wet sand, bottom-right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: 3,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 34: sand, top-left
      bkcolor: palette[14],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 0,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 35
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 36: sand, left
      bkcolor: palette[14],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -3,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: -1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 0,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 1,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 2,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 37
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 38
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 39
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 40
      bkcolor: palette[c['bright-red']]
    },
    { // autotile 41: wet sand, bottom-left
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: 3,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 42: sand, top
      bkcolor: palette[14],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: -1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 0,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 1,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 2,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 43: wet sand, dots top-left and top-right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        },
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 44: wet sand, top-right
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: 3,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 45: wet sand, top-left
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: -4,
          y: -4,
          radius: 2,
          color: palette[c.brown]
        }
      ]
    },
    { // autotile 46: sand
      bkcolor: palette[c['bright-yellow']],
      circles: [
        {
          x: 0,
          y: 0,
          radius: 1,
          color: palette[c.green]
        }
      ]
    },
    { // autotile 47
      bkcolor: palette[c['bright-red']]
    },
    { // start
      bkcolor: palette[c['light-gray']]
    },
    { // finish
      bkcolor: palette[c.black],
      circles: [
        {
          x: -3,
          y: -4,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -1,
          y: -4,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 1,
          y: -4,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 3,
          y: -4,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -4,
          y: -3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -2,
          y: -3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 0,
          y: -3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 2,
          y: -3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -3,
          y: -2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -1,
          y: -2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 1,
          y: -2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 3,
          y: -2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -4,
          y: -1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -2,
          y: -1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 0,
          y: -1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 2,
          y: -1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -3,
          y: 0,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -1,
          y: 0,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 1,
          y: 0,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 3,
          y: 0,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -4,
          y: 1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -2,
          y: 1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 0,
          y: 1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 2,
          y: 1,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -3,
          y: 2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -1,
          y: 2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 1,
          y: 2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 3,
          y: 2,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -4,
          y: 3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: -2,
          y: 3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 0,
          y: 3,
          radius: 1,
          color: palette[c['bright-white']]
        },
        {
          x: 2,
          y: 3,
          radius: 1,
          color: palette[c['bright-white']]
        }
      ]
    }
  ];

  /* global Image */

  function calcFinishTile ({ tileEngine }) {
    for (let y = 0; y < MAP_HEIGHT; ++y) {
      for (let x = 0; x < MAP_WIDTH; ++x) {
        if (tileEngine.tileAtLayer('ground', {
          x: x * TILE_WIDTH,
          y: y * TILE_HEIGHT
        }) === FINISH_TILE + 1) {
          return { x, y }
        }
      }
    }
  }

  function calcStartTile ({ tileEngine }) {
    for (let y = 0; y < MAP_HEIGHT; ++y) {
      for (let x = 0; x < MAP_WIDTH; ++x) {
        if (tileEngine.tileAtLayer('ground', {
          x: x * TILE_WIDTH,
          y: y * TILE_HEIGHT
        }) === START_TILE + 1) {
          return { x, y }
        }
      }
    }
  }

  function initTileEngine (cb) {
    const canvas = document.createElement('canvas');

    canvas.width = TILE_WIDTH * TILE_SHEET_WIDTH;
    canvas.height = TILE_HEIGHT * TILE_SHEET_HEIGHT;

    const context = canvas.getContext('2d');

    context.fillStyle = palette[c.black];
    context.fillRect(0, 0, canvas.width, canvas.height);

    const tile = makeTileSprite({ context });

    for (let y = 0; y < TILE_SHEET_HEIGHT; ++y) {
      for (let x = 0; x < TILE_SHEET_WIDTH; ++x) {
        if (y * TILE_SHEET_WIDTH + x >= tiles.length) {
          break
        }

        tile.bkcolor = tiles[y * TILE_SHEET_WIDTH + x].bkcolor;

        tile.circles = typeof tiles[y * TILE_SHEET_WIDTH + x].circles !== 'undefined'
          ? tiles[y * TILE_SHEET_WIDTH + x].circles : [];

        tile.x = x * TILE_WIDTH;
        tile.y = y * TILE_HEIGHT;

        tile.render();
      }
    }

    const image = new Image();

    image.onload = function () {
      let startTile = 0;
      let finishTile = 0;

      const tileEngine = TileEngine({
        tileheight: TILE_HEIGHT,
        tilewidth: TILE_WIDTH,

        width: MAP_WIDTH,
        height: MAP_HEIGHT,

        tilesets: [{
          firstgid: 1,
          image
        }],

        layers: [{
          data: levels[0].ground
            .map(tile => !startTile && tile === 62 ? (startTile = 64) : tile)
            .reverse()
            .map(tile => !finishTile && tile === 62 ? (finishTile = 65) : tile)
            .reverse()
            .map(tile => tile + 1),
          name: 'ground'
        }, {
          data: levels[0].collision,
          name: 'collision'
        }]
      });

      if (typeof cb === 'function') {
        cb(tileEngine);
      }
    };

    image.src = canvas.toDataURL();
  }

  /*
      joypad.js v1.2.9
      Copyright (c) 2019 Arun Michael Dsouza (amdsouza92@gmail.com)
      Licence: MIT
  */
  !function(t){var e={};function n(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o});},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(o,i,function(e){return t[e]}.bind(null,i));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=0);}([function(t,e,n){n.r(e);var o={events:{},publish:function(t,e){this.events.hasOwnProperty(t)&&this.events[t].forEach(t=>t(e));},subscribe:function(t,e){return this.events.hasOwnProperty(t)||(this.events[t]=[]),this.events[t].push(e),{unsubscribe:function(){this.events[t].splice(this.events[t].indexOf(e),1);}.bind(this)}}};const i={NATIVE:"gamepadconnected",ALIAS:"connect"},s={NATIVE:"gamepaddisconnected",ALIAS:"disconnect"},a={NATIVE:null,ALIAS:"button_press"},r={NATIVE:null,ALIAS:"axis_move"},d={NAME:"left_stick",AXES:{X:0,Y:1}},u={NAME:"right_stick",AXES:{X:2,Y:3}},c="left",p="right",l="top",b="bottom",A={button_0:0,button_1:1,button_2:2,button_3:3,button_4:4,button_5:5,button_6:6,button_7:7,button_8:8,button_9:9,button_10:10,button_11:11,button_12:12,button_13:13,button_14:14,button_15:15,button_16:16,button_17:17},f=t=>{console.warn&&"function"==typeof console.warn?console.warn(t):console.log(t);};var h={loopStarted:!1,instances:{},buttonEvents:{joypad:[]},settings:{axisMovementThreshold:.8},remove:function(t){return delete this.instances[t]},on:function(t,e){switch(t){case i.ALIAS:o.subscribe(i.ALIAS,e);break;case s.ALIAS:o.subscribe(s.ALIAS,e);break;case a.ALIAS:o.subscribe(a.ALIAS,e);break;case r.ALIAS:o.subscribe(r.ALIAS,e);}},vibrate:function(t,e){const{vibrationActuator:n}=t,o=e||this.settings.vibration;if((t=>!!(t&&t.type&&t.playEffect&&"function"==typeof t.playEffect))(n)){const{type:e}=n;return t.vibrationActuator.playEffect(e,o)}f("No vibration actuator interface found - https://developer.mozilla.org/en-US/docs/Web/API/GamepadHapticActuator");},set:function(t){const{axisMovementThreshold:e,vibration:n,customButtonMapping:o}=t,i=parseFloat(e);isNaN(i)||(this.settings.axisMovementThreshold=i),this.settings.vibration=n,this.settings.customButtonMapping=o;}};var v={id:null,start:function(){const t=window.requestAnimationFrame||window.webkitRequestAnimationFrame,e=window.navigator.getGamepads(),{buttonEvents:n}=h;Object.keys(e).length&&Object.keys(e).forEach(t=>{const o=e[t];o&&(n.joypad[t]||(n.joypad[t]={}),h.instances[t]=o,m(o),y(o));}),n.joypad.forEach(t=>{t&&Object.keys(t).forEach(e=>{w(e,t);});}),this.id=t(this.start.bind(this));},stop:function(t){return (window.cancelAnimationFrame||window.webkitCancelAnimationFrame)(t)}};const m=t=>{t.buttons.forEach((e,n)=>{const{customButtonMapping:o}=h.settings,i=((t,e)=>{let n=[];return Object.keys(e).forEach(o=>{e[o]===t?n.push(o):Array.isArray(e[o])&&-1!==e[o].indexOf(t)&&n.push(o);}),n})(n,o||A),{buttonEvents:s}=h;i&&i.length&&i.forEach(o=>{e.pressed?(s.joypad[t.index][o]||(s.joypad[t.index][o]={pressed:!0,hold:!1,released:!1}),s.joypad[t.index][o].button=e,s.joypad[t.index][o].index=n,s.joypad[t.index][o].gamepad=t):!e.pressed&&s.joypad[t.index][o]&&(s.joypad[t.index][o].released=!0,s.joypad[t.index][o].hold=!1);});});},y=t=>{const{axisMovementThreshold:e}=h.settings,{axes:n}=t,o=n.length/2;n.forEach((n,i)=>{if(Math.abs(n)>e){let e=null,s=null,a=n;e=i<o?d.NAME:u.NAME,i!==d.AXES.X&&i!==u.AXES.X||(s=n<0?c:p),i!==d.AXES.Y&&i!==u.AXES.Y||(s=n<0?l:b);const A={gamepad:t,totalSticks:o,stickMoved:e,directionOfMovement:s,axisMovementValue:a,axis:i};return window.dispatchEvent((t=>new CustomEvent(r.ALIAS,{detail:t}))(A))}});},w=(t,e)=>{if(e[t].pressed){const n=t=>new CustomEvent(a.ALIAS,{detail:t}),{index:o,gamepad:i}=e[t],s={buttonName:t,button:e[t].button,index:o,gamepad:i};window.dispatchEvent(n(s)),e[t].pressed=!1,e[t].hold=!0;}else e[t].hold||e[t].released&&delete e[t];};window.addEventListener(i.NATIVE,t=>{if(o.publish(i.ALIAS,t),!h.loopStarted)return h.loopStarted=!0,v.start()}),window.addEventListener(s.NATIVE,t=>{if(o.publish(s.ALIAS,t),h.remove(t.gamepad.index),h.buttonEvents.joypad[t.gamepad.index]=null,!Object.keys(h.instances).length)return h.loopStarted=!1,v.stop(v.id)}),window.addEventListener(a.ALIAS,t=>o.publish(a.ALIAS,t)),window.addEventListener(r.ALIAS,t=>o.publish(r.ALIAS,t)),(()=>!(!window.navigator.getGamepads||"function"!=typeof window.navigator.getGamepads))()?window.joypad=h:(window.joypad={},f("Your browser does not support the Gamepad API - https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API"));}]);

  const joypadAxis = { dx: 0, dy: 0 };

  const VirtualStick = exports.VirtualStick; // XXX

  const { canvas, context: context$1 } = init();

  canvas.width = SCREEN_WIDTH;
  canvas.height = SCREEN_HEIGHT;

  // const pal = makePaletteSprite(context)

  const loseCondition = ({ enemies, player }) => !!enemies.filter(enemy =>
    Math.abs(enemy.x - player.x) < player.width &&
    Math.abs(enemy.y - player.y) < player.height
  ).length;

  const winCondition = ({ coins, finishTile, player }) =>
    Math.floor((player.x + player.width / 2) / TILE_WIDTH) === finishTile.x &&
    // Math.floor((player.y + player.height / 2) / TILE_HEIGHT) === finishTile.y &&
    // coins.length === 0
    Math.floor((player.y + player.height / 2) / TILE_HEIGHT) === finishTile.y;

  function collectCoins ({ coins, player, totalCoins }) {
    const uncollectedCoins = coins.filter(coin =>
      !(Math.abs(coin.x - player.x) < player.width &&
      Math.abs(coin.y - player.y) < player.height));

    return {
      collected: uncollectedCoins.length < coins.length,
      uncollectedCoins
    }
  }

  function resetCoins ({ coins, finishTile, level, startTile, tileEngine }) {
    coins.length = 0;

    let numberOfCoins = 1 + Math.floor(level * (level / 13));
    if (numberOfCoins > 5) {
      numberOfCoins = 5;
    }

    for (let index = 0; index < numberOfCoins; ++index) {
      const coin = makeCoinSprite(context$1, tileEngine);

      let x, y;

      do {
        x = Math.floor(random$1() * MAP_WIDTH) * TILE_WIDTH + TILE_WIDTH / 8;
        y = Math.floor(random$1() * MAP_HEIGHT) * TILE_HEIGHT;
      } while ((tileEngine.tileAtLayer('collision', { x, y }) ||
        Math.floor(x / TILE_WIDTH) === startTile.x) ||
        (tileEngine.tileAtLayer('collision', { x, y }) ||
        Math.floor(x / TILE_WIDTH) === finishTile.x) ||
        tileEngine.tileAtLayer('ground', { x, y }) === START_TILE + 1 ||
        tileEngine.tileAtLayer('ground', { x, y }) === FINISH_TILE + 1)

      coin.x = x;
      coin.y = y;

      coins.push(coin);
    }
  }

  function resetEnemies ({ enemies, finishTile, level, startTile, tileEngine }) {
    enemies.length = 0;

    const numberOfEnemies = Math.floor(levels[level % levels.length].collision
      .map(tile => [1, 0][tile])
      .reduce((sum, tile) => sum + tile) / 13);

    for (let index = 0; index < numberOfEnemies; ++index) {
      const enemy = makeEnemySprite(context$1, tileEngine);

      let x, y;

      do {
        x = Math.floor(random$1() * MAP_WIDTH) * TILE_WIDTH + TILE_WIDTH / 8;
        y = Math.floor(random$1() * MAP_HEIGHT) * TILE_HEIGHT;
      } while ((tileEngine.tileAtLayer('collision', { x, y }) ||
        Math.floor(x / TILE_WIDTH) === startTile.x) ||
        (tileEngine.tileAtLayer('collision', { x, y }) ||
        Math.floor(x / TILE_WIDTH) === finishTile.x) ||
        tileEngine.tileAtLayer('ground', { x, y }) === START_TILE + 1 ||
        tileEngine.tileAtLayer('ground', { x, y }) === FINISH_TILE + 1)

      enemy.x = x;
      enemy.y = y;

      enemy.dy = random$1() < 0.5 ? -0.5 : 0.5;
      enemy.dy *= ((level + 1) / 3);

      enemies.push(enemy);
    }
  }

  function resetPlayer ({ player, startTile, tileEngine }) {
    player.tileEngine = tileEngine;

    player.x = TILE_WIDTH * startTile.x + TILE_WIDTH / 8;
    player.y = TILE_HEIGHT * (startTile.y + 0.125);
  }

  function resetTileEngine ({ level, tileEngine }) {
    let startTile = 0;
    let finishTile = 0;

    tileEngine.setLayer('collision', levels[level % levels.length].collision);
    tileEngine.setLayer('ground', levels[level % levels.length].ground
      .map(tile => !startTile && tile === 62 ? (startTile = 64) : tile)
      .reverse()
      .map(tile => !finishTile && tile === 62 ? (finishTile = 65) : tile)
      .reverse()
      .map(tile => tile + 1)
    );
  }

  function main () {
    let state;

    let level = 0;
    let totalCoins = 0;

    initTileEngine(tileEngine => {
      const font = makeFontSprite();

      let startTile = calcStartTile({ tileEngine });
      let finishTile = calcFinishTile({ tileEngine });

      const player = makePlayerSprite(context$1, tileEngine);
      resetPlayer({ player, startTile, tileEngine });

      const enemies = [];
      resetEnemies({ enemies, finishTile, level, startTile, tileEngine });

      let coins = [];
      resetCoins({ coins, finishTile, level, startTile, tileEngine });

      const resizeCanvas = makeResizeCanvas(canvas);

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      initKeys();

      const controller = new VirtualStick({
        container: document.getElementById('container')
      });

      window.joypad.set({ axisMovementThreshold: 0.3 });

      window.joypad.on('connect', e => {
        const { id } = e.gamepad;

        console.log(`${id} connected!`);
      });

      window.joypad.on('axis_move', ({ detail }) => {
        const { directionOfMovement, stickMoved } = detail;

        let { dx, dy } = joypadAxis;

        if (stickMoved === 'left_stick') {
          switch (directionOfMovement) {
            case 'left':
              dx = -1;
              break
            case 'right':
              dx = 1;
              break
            case 'top':
              dy = -1;
              break
            case 'bottom':
              dy = 1;
          }

          joypadAxis.dx = dx;
          joypadAxis.dy = dy;
        }
      });

      playSoundUnique('start');

      state = 'play';

      let loseFrameCount = 0;
      let winFrameCount = 0;

      const loop = GameLoop({
        render () {
          switch (state) {
            case 'lose': {
              context$1.fillStyle = palette[c.red];
              context$1.fillRect(0, 0, context$1.canvas.width, context$1.canvas.height);

              break
            }
            case 'play': {
              context$1.fillStyle = palette[c.black];
              context$1.fillRect(0, 0, context$1.canvas.width, context$1.canvas.height);

              tileEngine.renderLayer('ground');

              // pal.render()

              coins.forEach(coin => coin.render());

              player.render();

              enemies.forEach(enemy => enemy.render());

              // font.render()

              font.x = 4;
              font.y = 6;
              font.outputText('BACK TO THE ISLAND');

              font.y = 18;
              font.outputText('LEVEL: ' + (level + 1));

              font.x = SCREEN_WIDTH - VERSION.length * 4 - 4;
              font.y = 6;
              font.outputText(VERSION);

              font.x = 4;
              font.y = 24;
              font.outputText('SCORE: ' + totalCoins);

              controller.draw();

              break
            }
            case 'win': {
              context$1.fillStyle = palette[c.green];
              context$1.fillRect(0, 0, context$1.canvas.width, context$1.canvas.height);
            }
          }
        },

        update () {
          switch (state) {
            case 'lose': {
              if (loseFrameCount < 60) {
                ++loseFrameCount;
              } else {
                loseFrameCount = 0;

                resetPlayer({
                  player,
                  startTile,
                  tileEngine
                });

                playSoundUnique('start');

                state = 'play';
              }

              break
            }
            case 'play': {
              if (winCondition({ coins, finishTile, player })) {
                playSoundUnique('win');
                state = 'win';
              } else if (loseCondition({ enemies, player })) {
                playSoundUnique('lose');
                state = 'lose';
              }

              // collect coin(s)
              const { collected, uncollectedCoins } = collectCoins({ coins, player, totalCoins });

              if (collected) {
                coins = uncollectedCoins;
                ++totalCoins;
                playSound('collect');
              }

              // check for collision with enemies
              for (let index = 0; index < enemies.length; ++index) {
                const enemy = enemies[index];

                const { x } = enemy;
                let { dy, y } = enemy;

                y += dy;

                if (!tileEngine.layerCollidesWith('collision', {
                  x,
                  y,
                  width: enemy.width,
                  height: enemy.height
                })) {
                  enemies[index].y = y;
                } else {
                  dy *= -1;
                  enemies[index].dy = dy;
                }
              }

              if (keyPressed('left') || keyPressed('a') || keyPressed('q')) {
                player.moveWest();
              }
              if (keyPressed('right') || keyPressed('d')) {
                player.moveEast();
              }
              if (keyPressed('up') || keyPressed('w') || keyPressed('z')) {
                player.moveNorth();
              }
              if (keyPressed('down') || keyPressed('s')) {
                player.moveSouth();
              }

              {
                const { dx, dy } = controller.getAxis();

                if (dx < 0) {
                  player.moveWest();
                } else if (dx > 0) {
                  player.moveEast();
                }
                if (dy < 0) {
                  player.moveNorth();
                } else if (dy > 0) {
                  player.moveSouth();
                }
              }

              {
                const { dx, dy } = joypadAxis;

                if (dx < 0) {
                  player.moveWest();
                  joypadAxis.dx = 0;
                } else if (dx > 0) {
                  player.moveEast();
                  joypadAxis.dx = 0;
                }
                if (dy < 0) {
                  player.moveNorth();
                  joypadAxis.dy = 0;
                } else if (dy > 0) {
                  player.moveSouth();
                  joypadAxis.dy = 0;
                }
              }

              break
            }
            case 'win': {
              if (winFrameCount < 90) {
                ++winFrameCount;
              } else {
                winFrameCount = 0;

                ++level;

                resetTileEngine({
                  level,
                  tileEngine
                });

                startTile = calcStartTile({ tileEngine });
                finishTile = calcFinishTile({ tileEngine });

                resetPlayer({ player, startTile, tileEngine });
                resetCoins({ coins, finishTile, level, startTile, tileEngine });
                resetEnemies({ level, tileEngine, startTile, finishTile, enemies });

                playSoundUnique('start');

                state = 'play';
              }
            }
          }
        }
      });

      loop.start();
    });
  }

  main();

}());
</script>
</body>
</html>
